# 11강 사용자 전체의 특징과 경향 찾기
서비스를 제공한다=사용자에게 어떤 **가치**를 제공한다.
## 1.사용자의 액션 수 집계하기
서비스 내부의 기능등을 사용자가 얼마나 이용하는지 집계하는 작업은 사용자의 **행동 패턴** 파악과 **어떤 대책의 효과**를 확인할 때 굉장히 중요하며, 매우 자주 하게되는 작업
### 액션과 관련된 지표 집계하기
* **사용률(usage_rate)**: 특정 액션 UU/전체 액션 UU-> 사용자가 특정 액션을 얼마나 자주 사용하는지 확인 가능
  * UU: Unique Users, 중복없이 집계된 사용자 수
* **1명 당 액션 수(count_per_user)**: 사용자가 평균적으로 액션을 몇 번이나 사용하는지 확인해주는 지표
* 액션 수와 비율을 계산하는 쿼리
  ```sql
	  with
	stats as(
	select count(distinct session) as total_uu
	from action_log)
	
	select
	l.action,
	count(distinct l.session) as action_uu,
	count(*) as action_count,
	s.total_uu,
	100.0*count(distinct l.session)/s.total_uu as usage_rate,
	1.0*count(*)/count(distinct l.session) as count_per_user
	from action_log as l
	cross join 
	stats as s
	group by l.action,s.total_uu
  ```
  * 전체 UU를 구하고 그 값을 CROSS JOIN하여 액션 로그로 결합, 이후 액션들을 집약해서 지표를 구한다.
### 로그인 사용자와 비로그인 사용자를 구분해서 집계하기
로그인하지 않아도 서비스 일부를 사용할 수 있는 경우, 회원&비회원을 따로 나누어 집계하는 것이 좋다.                           
이를 통해, 서비스에 대한 충성도가 높은 사용자와 낮은 사용자가 어떤 경향을 보이는지 발견할 수 있다.                                   
로그인, 비로그인, 회원, 비회원을 판별할 때는 로그 데이터에 session 정보가 있어야 한다.
* 로그인 상태를 판별하는 쿼리
  ```sql
  with 
	action_log_with_status as (
	select
		session,
		user_id,
		action,
		case when coalesce(user_id,'')<>'' then 'login' else 'guest' end as login_status
	from action_log)
	
	select * from action_log_with_status
  ```
  * user_id에 값이 들어 있다면 login_status=login, 들어있지 않다면 login_status=guest
* 로그인 상태에 따라 액션 수 등을 따로 집계하는 쿼리
  ```sql
  with 
	action_log_with_status as (
	select
		session,
		user_id,
		action,
		case when coalesce(user_id,'')<>'' then 'login' else 'guest' end as login_status
	from action_log)
	
	select
	coalesce(action,'all') as action,
	coalesce(login_status,'all') as login_status,
	count(distinct session) as action_uu,
	count(*) as action_count
	from 
	action_log_with_status
	group by
	rollup(action,login_status)
  ```
  * 로그 정보의 user_id 정보를 기반으로 집계한 데이터이므로, 비로그인 사용자가 로그인하면 각각의 액션에 1씩 추가된다.
  * all은 session을 기반으로 집계한다, 따라서 guset+login=all이 아니다.
### 회원과 비회원을 구분해서 집계하기
* 회원 상태를 판별하는 쿼리
  ```sql
  with 
	action_log_with_status as(
	select
		session,user_id,action,
		case
		when
		coalesce(max(user_id) over(partition by session order by stamp rows between unbounded preceding and current row),'')<>'' then 'member'
		else 'none'
		end as member_status,
		stamp
	from action_log
	)
	
	select * from action_log_with_status
  ```
### 원포인트
* 로그인하지 않은 상태일 경우 사용자 ID 컬럼의 값이 빈 분자열 또는 NULL일 수 있다고 판단해서, COALESCE 함수를 사용해 빈 문자열로 변환
* 로그인하지 않은 때의 사용자 ID를 빈 문자열로 저장했다면, COUNT(DISTINCT user_id)의 결과에 1이 추가된다. 따라서 COUNT(DISTINCT user_id)로 사용자 수를 정확하게 추출하려면 사용자 ID를 NULL로 지정하는 것이 좋다.
* 비어있는 값을 NULL로 나타낼지, 빈 문자열 등의 특수한 값으로 나타낼지에 따라 쿼리의 최적화 방법이 달라질 수 있다. 따라서 COALESCE 함수 또는 NULLIF 함수를 사용해 서로 변환하는 방법을 기억해두는 것이 좋다.
## 2. 연령별 구분 집계하기
처음 가입할 때 나이를 입력받아 데이터베이스에 저장하면, 시간이 지나면서 실제 나이와 일치하지 않게 된다.                           
따라서, 일반적으로는 나이는 따로 DB에 저장하지 않고, 생일을 기반으로 리포트를 만드는 시점에 집계한다.
* 사용자의 생일을 계산하는 쿼리
  ```sql
  with 
	mst_users_with_int_birth_date as (
	select
		*,20170101 as int_specific_date,
		cast(replace(substring(birth_date,1,10),'-','') as integer) as int_birth_date
		from mst_users)
	,
	mst_users_with_age as (
		select
		*,
		floor((int_specific_date-int_birth_date)/10000) as age
	from mst_users_with_int_birth_date)
	
	
	select
	user_id,sex,birth_date,age
	from mst_users_with_age
  ```
* 성별과 연령으로 연령별 구분을 계산하는 쿼리
  ```sql
  with 
	mst_users_with_int_birth_date as (
	select
		*,20170101 as int_specific_date,
		cast(replace(substring(birth_date,1,10),'-','') as integer) as int_birth_date
		from mst_users)
	,
	mst_users_with_age as (
		select
		*,
		floor((int_specific_date-int_birth_date)/10000) as age
	from mst_users_with_int_birth_date)
	,
	mst_users_with_category as (
	select
		user_id,sex,age,
		concat(case
			  when 20<=age then sex
			  else '' end,
			  case
			   when age between 4 and 12 then 'C'
			   when age between 13 and 19 then 'T'
			   when age between 20 and 34 then '1'
			   when age between 35 and 49 then '2'
			   when age>=50 then '3'
			   end) as category
			from mst_users_with_age)
	
	select * from mst_users_with_category
  ```
  * 연령이 3살 이하인 사용자의 경우 연령구분 코드가 NULL이 되어 CONCAT의 결과도 NULL이 된다.(CONCAT함수는 매개 변수 중 하나만 NULL이어도 전체 결과가 NULL이 된다.)
* 연령별 구분의 사람 수를 계산하는 쿼리
  ```sql
  with 
	mst_users_with_int_birth_date as (
	select
		*,20170101 as int_specific_date,
		cast(replace(substring(birth_date,1,10),'-','') as integer) as int_birth_date
		from mst_users)
	,
	mst_users_with_age as (
		select
		*,
		floor((int_specific_date-int_birth_date)/10000) as age
	from mst_users_with_int_birth_date)
	,
	mst_users_with_category as (
	select
		user_id,sex,age,
		concat(case
			  when 20<=age then sex
			  else '' end,
			  case
			   when age between 4 and 12 then 'C'
			   when age between 13 and 19 then 'T'
			   when age between 20 and 34 then '1'
			   when age between 35 and 49 then '2'
			   when age>=50 then '3'
			   end) as category
			from mst_users_with_age)
	
	select
	category,
	count(*) as user_count
	from mst_users_with_category
	group by category
  ```
## 3. 연령별 구분의 특징 추출하기
서비스의 사용 형태가 사용자 속성에 따라 다르다는 것을 확인하면 상품 또는 기사를 사용자 속성에 맞게 추천할 수 있다.                      
그러면 상품을 더 구매하거나 기사를 더 클릭하게 만들 수 있다. 
* 연령별 구분과 카테고리를 집계하는 쿼리
  ```sql
  with 
	mst_users_with_int_birth_date as (
	select
		*,20170101 as int_specific_date,
		cast(replace(substring(birth_date,1,10),'-','') as integer) as int_birth_date
		from mst_users)
	,
	mst_users_with_age as (
		select
		*,
		floor((int_specific_date-int_birth_date)/10000) as age
	from mst_users_with_int_birth_date)
	,
	mst_users_with_category as (
	select
		user_id,sex,age,
		concat(case
			  when 20<=age then sex
			  else '' end,
			  case
			   when age between 4 and 12 then 'C'
			   when age between 13 and 19 then 'T'
			   when age between 20 and 34 then '1'
			   when age between 35 and 49 then '2'
			   when age>=50 then '3'
			   end) as category
			from mst_users_with_age)
	
	select
	p.category as product_category,
	u.category as user_category,
	count(*) as purchase_count
	from action_log as p
	join mst_users_with_category as u
	on p.user_id=u.user_id
	where action='purchase'
	group by p.category,u.category
	order by p.category,u.category
  ```
### 원포인트
ABC 분석과 구성비누계를 리포트에 추가하면, 리포트의 내용 전달성을 향상 시킬 수 있다.
## 4. 사용자의 방문 빈도 집계하기
사용자가 일주일 또는 한 달 동안 서비스를 얼마나 쓰는지 확인하는 방법 ex) '일주일에 한 번만 방문하는 사용자'와 '매일 방문하는 사용자'간의 행동 패턴 차이 분석
* 한 주에 며칠 사용되었는지를 집계하는 쿼리
  ```sql
	  with
	action_log_with_dt as (
		select*,
		substring(stamp,1,10) as dt_1
	from action_log),
	
	action_day_count_per_user as (
		select
		user_id,
		count(distinct dt_1) as action_day_count
	from action_log_with_dt
	where dt between '2016-11-01' and '2016-11-07'
	group by user_id)
	
	
	select
	action_day_count,
	count(distinct user_id) as user_count
	from
	action_day_count_per_user
	group by action_day_count
	order by action_day_count
  ```
* 구성비와 구성비누계를 계산하는 쿼리
  ```sql
	  with
	action_log_with_dt as (
		select*,
		substring(stamp,1,10) as dt_1
	from action_log),
	
	action_day_count_per_user as (
		select
		user_id,
		count(distinct dt_1) as action_day_count
	from action_log_with_dt
	where dt between '2016-11-01' and '2016-11-07'
	group by user_id)
	
	SELECT
	    action_day_count,
	    COUNT(DISTINCT user_id) AS user_count,
	    100.0 * COUNT(DISTINCT user_id) / SUM(COUNT(DISTINCT user_id)) OVER () AS composition_ratio,
	    100.0 * SUM(COUNT(DISTINCT user_id)) OVER (
	        ORDER BY action_day_count
	        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
	    ) / SUM(COUNT(DISTINCT user_id)) OVER () AS cumulative_ratio
	FROM action_day_count_per_user
	GROUP BY action_day_count
	ORDER BY action_day_count;
  ```  
## 5.벤 다이어그램으로 사용자 액션 집계하기
서비스 내부에서 여러 기능을 제공하더라도 그러한 기능을 모두 사용하는 사용자는 많지 않다.                          
따라서 여러 기능의 사용상황을 조사한 뒤 제공하는 기능을 사용자가 받아들이는지, 예상대로 사용하는지 등을 확인해야 한다.                      
* 사용자들의 액션 플래그를 집계하는 쿼리
  ```sql
  with 
	user_action_flag as (
	select
		user_id,
		sign(sum(case when action='purchase' then 1 else 0 end)) as has_purchase,
		sign(sum(case when action='review' then 1 else 0 end)) as has_review,
		sign(sum(case when action='favorite' then 1 else 0 end)) as has_favorite
	from action_log
	group by user_id)
	
	
	select * 
	from user_action_flag
  ```
  * 각각의 액션을 실행했다면 1, 실행하지 않았다면 0을 나타낸다.
  * 대부분의 리포트 도구에는 앞의 데이터를 파일로 입력하면 곧바로 벤다이어그램을 만들어주는 기능을 가지고 있다.
* 모든 액션 조합에 대한 사용자 수 계산하기
  * '구매 액션만 한 사용자 수' 또는 '구매와 리뷰 액션을 한 사용자 수'같이 하나의 액션 또는 두개의 액션을 한 사용자가 몇 명인지 계산한다.
  ```sql
	  with 
	user_action_flag as (
	select
		user_id,
		sign(sum(case when action='purchase' then 1 else 0 end)) as has_purchase,
		sign(sum(case when action='review' then 1 else 0 end)) as has_review,
		sign(sum(case when action='favorite' then 1 else 0 end)) as has_favorite
	from action_log
	group by user_id),
	
	action_venn_diagram as (
		select
		has_purchase,
		has_review,
		has_favorite,
		count(*) as users
	from user_action_flag
	group by cube(has_purchase,has_review,has_favorite))
	
	select * 
	from action_venn_diagram
	order by has_purchase,has_review,has_favorite
  ```
  * **CUBE**구문을 사용한 쿼리
  * Null 레코드는 해당 액션을 했는지 안 했는지 모르는 경우를 의미
* 벤 다이어그램을 만들기 위해 데이터를 가공하는 쿼리
  ```sql
	  with 
	user_action_flag as (
	select
		user_id,
		sign(sum(case when action='purchase' then 1 else 0 end)) as has_purchase,
		sign(sum(case when action='review' then 1 else 0 end)) as has_review,
		sign(sum(case when action='favorite' then 1 else 0 end)) as has_favorite
	from action_log
	group by user_id),
	
	action_venn_diagram as (
		select
		has_purchase,
		has_review,
		has_favorite,
		count(*) as users
	from user_action_flag
	group by cube(has_purchase,has_review,has_favorite))
	
	
	select
	case has_purchase
	when 1 then 'purchase' when 0 then 'not purchase' else 'any' end as has_purchase,
	case has_review
	when 1 then 'review' when 0 then 'not review' else 'any' end as has_review,
	case has_favorite
	when 1 then 'favorite' when 0 then 'not favorite' else 'any' end as has_favorite,
	users,
	100.0*users/
	nullif(sum(case when has_purchase is null
			  and has_review is null
			  and has_favorite is null
			  then users else 0 end) over()
		  ,0) as ratio
	from action_venn_diagram
	order by has_purchase,has_review,has_favorite
  ```
  * purchase/any/any: 구매 액션을 한 사용자
  * purchase/not review/any: 구매액션을 했지만 리뷰를 작성하지 않은 사용자
  * any/any/any: 모든 사용자의 수
## 6.Decile 분석을 사용해 사용자를 10단계 그룹으로 나누기
사용자 특징을 분석할 때 성별과 연령 등의 데이터가 있다면 이러한 속성에 따른 특징을 확인 할 수 있다.                                
데모그래픽한 데이터가 존재하지 않는 경우, 사용자 액션으로 속성을 정의 해보는 것도 좋다. 
* **Decile 분석**: 데이터를 10단계로 분할해서 중요도를 파악하는 방법
* **Decile 분석과정**
  1. 사용자를 구매 금액이 많은 순으로 정렬
  2. 정렬된 사용자 상위부터 10%씩 Decile 1부터 Decile 10까지의 그룹을 할당
  3. 각 그룹의 구매 금액 합계를 집계
  4. 전체 구매 금액에 대해 각 Decile의 구매 금액 비율을 계산
  5. 상위에서 누적으로 어느 정도의 비율을 차지하는지 구성비누계를 집계
* 구매액이 많은 순서로 사용자 그룹을 10등분하는 쿼리
  ```sql
	  with user_purchase_amount as (
	select
		user_id,
		sum(amount) as purchase_amount	
	from action_log
	where action='purchase'
	group by user_id),
	
	users_with_decile as(
	select
		user_id,
		purchase_amount,
		ntile(10) over (order by purchase_amount desc) as decile
	from user_purchase_amount)
	
	select * 
	from users_with_decile
  ```
  * 사용자를 무매 금액이 많은 순서로 정렬하고, 정렬된 사용자의 상위에서 10*씩 Decile1 부터 Decile10까지의 그룹을 할당한 것
  * 같은 수로 데이터 그룹을 만들때 **NTILE** 윈도 함수 사용
* 10분할한 Decile들을 집계하는 쿼리
  ```sql
  with user_purchase_amount as (
	select
		user_id,
		sum(amount) as purchase_amount	
	from action_log
	where action='purchase'
	group by user_id),
	
	users_with_decile as(
	select
		user_id,
		purchase_amount,
		ntile(10) over (order by purchase_amount desc) as decile
	from user_purchase_amount),
	
	decile_with_purchase_amount as (
	select
		decile,
		sum(purchase_amount) as amount,
		avg(purchase_amount) as avg_amount,
		sum(sum(purchase_amount)) over (order by decile) as cumulative_amount,
		sum(sum(purchase_amount)) over () as total_amount
	from users_with_decile
	group by decile)
	
	select * 
	from decile_with_purchase_amount
  ```
  * 각 그룹의 합계, 평균 구매 금액, 누계 구매 금액, 전체 구매 금액등의 집약을 계산
* 구매액이 많은 Decile 순서로 구성비와 구성 비누계를 계산하는 쿼리
  ```sql
	select
	case has_purchase
	when 1 then 'purchase' when 0 then 'not purchase' else 'any' end as has_purchase,
	case has_review
	when 1 then 'review' when 0 then 'not review' else 'any' end as has_review,
	case has_favorite
	when 1 then 'favorite' when 0 then 'not favorite' else 'any' end as has_favorite,
	users,
	100.0*users/
	nullif(sum(case when has_purchase is null
			  and has_review is null
			  and has_favorite is null
			  then users else 0 end) over()
		  ,0) as ratio
	from action_venn_diagram
	order by has_purchase,has_review,has_favorite
  ```
  * purchase/any/any: 구매 액션을 한 사용자
  * purchase/not review/any: 구매액션을 했지만 리뷰를 작성하지 않은 사용자
  * any/any/any: 모든 사용자의 수
## 6.Decile 분석을 사용해 사용자를 10단계 그룹으로 나누기
사용자 특징을 분석할 때 성별과 연령 등의 데이터가 있다면 이러한 속성에 따른 특징을 확인 할 수 있다.                                
데모그래픽한 데이터가 존재하지 않는 경우, 사용자 액션으로 속성을 정의 해보는 것도 좋다. 
* **Decile 분석**: 데이터를 10단계로 분할해서 중요도를 파악하는 방법
* **Decile 분석과정**
  1. 사용자를 구매 금액이 많은 순으로 정렬
  2. 정렬된 사용자 상위부터 10%씩 Decile 1부터 Decile 10까지의 그룹을 할당
  3. 각 그룹의 구매 금액 합계를 집계
  4. 전체 구매 금액에 대해 각 Decile의 구매 금액 비율을 계산
  5. 상위에서 누적으로 어느 정도의 비율을 차지하는지 구성비누계를 집계
* 구매액이 많은 순서로 사용자 그룹을 10등분하는 쿼리
  ```sql
	  with user_purchase_amount as (
	select
		user_id,
		sum(amount) as purchase_amount	
	from action_log
	where action='purchase'
	group by user_id),
	
	users_with_decile as(
	select
		user_id,
		purchase_amount,
		ntile(10) over (order by purchase_amount desc) as decile
	from user_purchase_amount)
	
	select * 
	from users_with_decile
  ```
  * 사용자를 무매 금액이 많은 순서로 정렬하고, 정렬된 사용자의 상위에서 10*씩 Decile1 부터 Decile10까지의 그룹을 할당한 것
  * 같은 수로 데이터 그룹을 만들때 **NTILE** 윈도 함수 사용
* 10분할한 Decile들을 집계하는 쿼리
  ```sql
  with user_purchase_amount as (
	select
		user_id,
		sum(amount) as purchase_amount	
	from action_log
	where action='purchase'
	group by user_id),
	
	users_with_decile as(
	select
		user_id,
		purchase_amount,
		ntile(10) over (order by purchase_amount desc) as decile
	from user_purchase_amount),
	
	decile_with_purchase_amount as (
	select
		decile,
		sum(purchase_amount) as amount,
		avg(purchase_amount) as avg_amount,
		sum(sum(purchase_amount)) over (order by decile) as cumulative_amount,
		sum(sum(purchase_amount)) over () as total_amount
	from users_with_decile
	group by decile)
	
	select * 
	from decile_with_purchase_amount
  ```
  * 각 그룹의 합계, 평균 구매 금액, 누계 구매 금액, 전체 구매 금액등의 집약을 계산
* 구매액이 많은 Decile 순서로 구성비와 구성 비누계를 계산하는 쿼리
  ```sql
  with user_purchase_amount as (
	select
		user_id,
		sum(amount) as purchase_amount	
	from action_log
	where action='purchase'
	group by user_id),
	
	users_with_decile as(
	select
		user_id,
		purchase_amount,
		ntile(10) over (order by purchase_amount desc) as decile
	from user_purchase_amount),
	
	decile_with_purchase_amount as (
	select
		decile,
		sum(purchase_amount) as amount,
		avg(purchase_amount) as avg_amount,
		sum(sum(purchase_amount)) over (order by decile) as cumulative_amount,
		sum(sum(purchase_amount)) over () as total_amount
	from users_with_decile
	group by decile)
	
	select
	decile,amount,avg_amount,
	100.0*amount/total_amount as total_ratio,
	100.0*cumulative_amount/total_amount as cumulative_ratio
	from 
	decile_with_purchase_amount
  ```
### 원포인트
* Decile 분석을 시행하고, Decile의 특징을 다른 분석 방법으로 세분화해서 조사하면 사용자의 속성을 자세하게 파악할 수 있다.
* Decile 7~10은 정착되지 않은 고객을 나타낸다. 따라서 메일 매거진 등으로 리텐션을 높이는 등의 대책을 세울 수 있다.
  * 만약 메일 메거진을 이미 보내고 있다면, 메일 메거진을 보낼 때 추가적인 데이터를 수집해서 Decile 7~10에 해당하는 사람들의 속성과 관련된 데이터를 더 수집하고 활용할 수 있다.
## 7.RFM 분석으로 사용자를 3가지 관점의 그룹으로 나누기
* Decile 분석의 단점- **검색기간**에 따라 문제가 있다.
  * 검색 기간이 너무 길 경우: 과거에 우수 고객이었어도 현재는 다른 서비스를 사용하는 휴면 고객에 포함되었을 가능성 존재
  * 검색 기간이 너무 짧을 경우: 정기적으로 구매하는 안정 고객이 포함되지 않고, 해당 기간동안에만 일시적으로 많이 구매한 사용자가 우수 고객으로 취급될 가능성 존재
  * **RFM 분석을 통해 사용자를 Decile분석보다 조금 더 자세하게 사용자를 그룹으로 나눌 수 있다.**
### RFM 분석의 3가지 지표 집계하기
* **Recency(최근 구매일)**: 최근 무언가를 구매한 사용자를 우량고객으로 취급
* **Frequency(구매 횟수)**: 사용자가 구매한 횟수를 세고, 많을수록 우량고객으로 취급
* **Monetary(구매 금액 합계)**: 사용자의 구매 금액 합계를 집계하고, 금액이 높을수록 우량 고객으로 취급
* 사용자별로 RFM을 집계하는 쿼리
  ```sql
  with
	purchase_log as (
	select
		user_id,amount,
		substring(stamp,1,10) as dt
	from action_log
	where
	action='purchase'),
	
	user_rfm as (
	select
		user_id,
		max(dt) as recent_date,
		current_date-max(dt::date) as recency,
		count(dt) as frequency,
		sum(amount) as monetary
	from purchase_log
	group by user_id)
	
	select *
	from user_rfm
  ```
### RFM 랭크 정의하기
* 3개의 지표를 각각 5개의 그룹으로 나누는 것이 일반적-이렇게 하면 125(5*5*5)개의 그룹으로 사용자를 나눠 파악할 수 있다.
* **사용자들의 RFM 랭크를 계산하는 쿼리**
  ```sql
  with
	purchase_log as (
	select
		user_id,amount,
		substring(stamp,1,10) as dt
	from action_log
	where
	action='purchase'),
	
	user_rfm as (
	select
		user_id,
		max(dt) as recent_date,
		current_date-max(dt::date) as recency,
		count(dt) as frequency,
		sum(amount) as monetary
	from purchase_log
	group by user_id),
	
	user_frm_rank as (
	select
		user_id,recent_date,recency,frequency,monetary,
		case
		when recency<14 then 5
		when recency<28 then 4
		when recency<60 then 3
		when recency<90 then 2
		else 1
		end as r,
		case
		when 20<=frequency then 5
		when 10<=frequency then 4
		when 5<=frequency then 3
		when 2<=frequency then 2
		when 1=frequency then 1 end as f,
		case
		when 300000<=monetary then 5
		when 100000<=monetary then 4
		when 30000<=monetary then 3
		when 5000<=monetary then 2
		else 1
		end as m
	from user_rfm)
	
	select * from user_rfm_rank
  ```
* 각 그룹의 사람 수를 확인하는 쿼리
  ```sql
	  with
	purchase_log as (
	select
		user_id,amount,
		substring(stamp,1,10) as dt
	from action_log
	where
	action='purchase'),
	
	user_rfm as (
	select
		user_id,
		max(dt) as recent_date,
		current_date-max(dt::date) as recency,
		count(dt) as frequency,
		sum(amount) as monetary
	from purchase_log
	group by user_id),
	
	user_frm_rank as (
	select
		user_id,recent_date,recency,frequency,monetary,
		case
		when recency<14 then 5
		when recency<28 then 4
		when recency<60 then 3
		when recency<90 then 2
		else 1
		end as r,
		case
		when 20<=frequency then 5
		when 10<=frequency then 4
		when 5<=frequency then 3
		when 2<=frequency then 2
		when 1=frequency then 1
		end as f,
		case
		when 300000<=monetary then 5
		when 100000<=monetary then 4
		when 30000<=monetary then 3
		when 5000<=monetary then 2
		else 1
		end as m
	from user_rfm),
	
	mst_rfm_index as (
	select 1 as rfm_index
	union all select 2 as rfm_index
	union all select 3 as rfm_index
	union all select 4 as rfm_index
	union all select 5 as rfm_index)
	,
	
	rfm_flag as(
	select
		m.rfm_index,
		case when m.rfm_index=r.r then 1 else 0 end as r_flag,
		case when m.rfm_index=r.f then 1 else 0 end as f_flag,
		case when m.rfm_index=r.m then 1 else 0 end as m_flag
	from mst_rfm_index as m
	cross join user_rfm_rank as r)
	
	select
	frm_index,
	sum(r_flag) as r,
	sum(f_flag) as f,
	sum(m_flag) as m
	from rfm_flag
	group by rfm_index
	order by rfm_index desc
  ```
극단적으로 적은 사용자 수의 그룹이 발생한다면 RFM 랭크 정의를 수정해주어야 한다.
### 사용자를 1차원으로 구분하기
RFM 분석을 3차원으로 표현하면 125개의 그룹이 발생하므로 굉장히 관리하기 어렵다.                            
RFM의 각 랭크 합계를 기반으로 13개 그룹으로 나눈어 관리하는 방법도 존재한다.
* R+F+M 값을 통합 랭크로 계산하는 쿼리 작성
  ```sql
  with
	purchase_log as (
	select
		user_id,amount,
		substring(stamp,1,10) as dt
	from action_log
	where
	action='purchase'),
	
	user_rfm as (
	select
		user_id,
		max(dt) as recent_date,
		current_date-max(dt::date) as recency,
		count(dt) as frequency,
		sum(amount) as monetary
	from purchase_log
	group by user_id),
	
	user_frm_rank as (
	select
		user_id,recent_date,recency,frequency,monetary,
		case
		when recency<14 then 5
		when recency<28 then 4
		when recency<60 then 3
		when recency<90 then 2
		else 1
		end as r,
		case
		when 20<=frequency then 5
		when 10<=frequency then 4
		when 5<=frequency then 3
		when 2<=frequency then 2
		when 1=frequency then 1
		end as f,
		case
		when 300000<=monetary then 5
		when 100000<=monetary then 4
		when 30000<=monetary then 3
		when 5000<=monetary then 2
		else 1
		end as m
	from user_rfm)
	
	select
	r+f+m as total_rank,
	r,f,m,
	count(user_id)
	from
	user_rfm_rank
	group by r,f,m
	order by total_rank,r desc, f desc, m desc
  ```  
* 종합 랭크별로 사용자 수를 집계하는 쿼리
  ```sql
	  with
	purchase_log as (
	select
		user_id,amount,
		substring(stamp,1,10) as dt
	from action_log
	where
	action='purchase'),
	
	user_rfm as (
	select
		user_id,
		max(dt) as recent_date,
		current_date-max(dt::date) as recency,
		count(dt) as frequency,
		sum(amount) as monetary
	from purchase_log
	group by user_id),
	
	user_frm_rank as (
	select
		user_id,recent_date,recency,frequency,monetary,
		case
		when recency<14 then 5
		when recency<28 then 4
		when recency<60 then 3
		when recency<90 then 2
		else 1
		end as r,
		case
		when 20<=frequency then 5
		when 10<=frequency then 4
		when 5<=frequency then 3
		when 2<=frequency then 2
		when 1=frequency then 1
		end as f,
		case
		when 300000<=monetary then 5
		when 100000<=monetary then 4
		when 30000<=monetary then 3
		when 5000<=monetary then 2
		else 1
		end as m
	from user_rfm)
	
	select
	r+f+m as total_rank,
	count(user_id)
	from user_rfm_rank
	group by total_rank
	order by total_rank desc
  ```
### 2차원으로 사용자 인식하기
RFM 지표 2개를 사용해서 사용자 층을 정의하는 방법
* RFM 지표 2개를 사용해서 사용자 층을 정의하기
  ```sql
	  with
	purchase_log as (
	select
		user_id,amount,
		substring(stamp,1,10) as dt
	from action_log
	where
	action='purchase'),
	
	user_rfm as (
	select
		user_id,
		max(dt) as recent_date,
		current_date-max(dt::date) as recency,
		count(dt) as frequency,
		sum(amount) as monetary
	from purchase_log
	group by user_id),
	
	user_frm_rank as (
	select
		user_id,recent_date,recency,frequency,monetary,
		case
		when recency<14 then 5
		when recency<28 then 4
		when recency<60 then 3
		when recency<90 then 2
		else 1
		end as r,
		case
		when 20<=frequency then 5
		when 10<=frequency then 4
		when 5<=frequency then 3
		when 2<=frequency then 2
		when 1=frequency then 1
		end as f,
		case
		when 300000<=monetary then 5
		when 100000<=monetary then 4
		when 30000<=monetary then 3
		when 5000<=monetary then 2
		else 1
		end as m
	from user_rfm)
	
	select
	concat('r_',r) as r_rank,
	count(case when f=5 then 1 end) as f_5,
	count(case when f=4 then 1 end) as f_4,
	count(case when f=3 then 1 end) as f_3,
	count(case when f=2 then 1 end) as f_2,
	count(case when f=1 then 1 end) as f_1
	from user_rfm_rank
	group by r
	order by r_rank desc
  ```
# 12강 시계열에 따른 사용자 전체의 상태 변화 찾기
* 서비스 사용 시작 후 사용자의 상태 변화
  * 리피트(충성도가 높은 사용자): 사용자가 계속해서 사용
  * 탈퇴/휴먼: 사용자가 사용을 중단(사용을 중지, 가입은 되어 있지만 사용하지 않는 상태(휴면))

서비스를 운영하는 입장에서는 사용자가 서비스를 계속해서 사용하기를 원한다.
이를 위해 사용자가 어느 정도 계속해서 서비스를 사용하는지 파악, 목표와의 괴리를 어떻게 해결할지에 대해 고민해야 한다.                                
추가로, 휴면 사용자를 어떻게 다시 서비스를 사용하게 만들지도 계속해서 생각해야 한다.(탈퇴한 사용자들에게는 대책을 적용하기 힘들지만, 휴면 사용자는 메일 매거진/CM/광고 등을 활용해 다시 사용하게 만들 수 있다.)          
## 1. 등록 수의 추이와 경향 보기
사용자 등록이 필요한 서비스에서 **등록 수**는 중요한 지표 중 하나                                          
* 등록자가 감소 경향을 보인다: 서비스를 활성화하기 어려워진다.
* 등록자가 증가 경향을 보인다: 사용자가 서비스에서 이탈할지 아닐지를 분석해서 서비스 활성화와 연결할 수 있어야 한다.
****
* 날짜별 등록 수의 추이를 집계하는 쿼리
  ```sql
  select
	register_date,
	count(distinct user_id) as register_count
	from mst_users
	group by register_date
	order by register_date
  ```
  * 사용자를 유일하게 식별할 수 있는 ID로 중복을 제거
### 월별 등록 수 추이
* 매달 등록 수와 전월비를 계산하는 쿼리(전월비: 이전 달과의 비율)
  ```sql
  with 
	mst_users_with_year_month as (
	select
		*,
		substring(register_date,1,7) as year_month
	from mst_users)
	
	
	select
	year_month,
	count(distinct user_id) as register_count,
	lag(count(distinct user_id)) over(order by year_month) as last_month_count,
	1.0*count(distinct user_id)/lag(count(distinct user_id)) over(order by year_month) as month_over_month_ratio
	from
	mst_users_with_year_month
	group by year_month
  ```
  * **LAG** 윈도 함수를 사용해 전월 등록 수, 전월비를 집계
### 등록 디바이스별 추이
월별 등록자 집계 후, 레코드 내에 저장된 정보를 사용해서 여러 가지 내역을 집계할 수 있다.
* 디바이스들의 등록 수를 집계하는 쿼리
  ```sql
  with 
	mst_users_with_year_month as (
	select
		*,
		substring(register_date,1,7) as year_month
	from mst_users)
	
	
	select
	year_month,
	count(distinct user_id) as register_count,
	count(distinct case when register_device='pc' then user_id end) as register_pc,
	count(distinct case when register_device='sp' then user_id end) as register_sp,
	count(distinct case when register_device='app' then user_id end) as register_app
	from 
	mst_users_with_year_month
	group by year_month
  ```
## 2. 지속률과 정착률 산출하기
사용자가 등록하더라도 서비스를 지속해서 사용하지 않는다면, 사용자가 아무리 많아도 활용으로 이어지지 않는다는 것을 의미                                        
등록 시점을 기준으로 일정 기간 동안 사용자가 지속해서 사용하고 있는지를 조사할 때, **지속률**과 **정착률**을 사용하면 경향을 쉽게 파악할 수 있다.
### 지속률과 정착률의 정의
* **지속률**: 등록일 기준으로 이후 지정일 동안 사용자가 서비스를 얼마나 이용했는지 나타내는 지표
  * 지속률=<사용자 수>/<등록 수>
* **정착률**: 등록일 기준으로 이후 지정한 7일 동안 사용자가 서비스를 사용했는지 나타내는 지표(지속과는 다르게 7일이라는 기간에 한 번이라도 서비스를 사용했다면 정착자로 다룬다.)
  * 7일 정착률: 등록 후 1일 부터 7일까지의 정착률을 기준으로 산출
  * 14일 정착률: 이후의 7일이 판정 기간(등록일부터 8일 후부터 14일까지의 정착률)
  * 7일 동안 서비스를 사용한 날짜가 하루든 3일이든 상관없이 정착률은 모두 1로 취급된다.
  * 정착률=<사용자 수>/<등록 수>
### 지속률과 정착률 사용 구분하기
* 지속률과 정착률의 사용 구분 포인트
  * 지속률: 사용자가 매일 사용했으면 하는 서비스 ex) 뉴스 사이트, 소셜 게임, SNS 등
  * 정착률: 사용자에게 어떤 목적이 생겼을 때 사용했으면 하는 서비스 ex) EC 사이트, 리뷰 사이트, Q&A 사이트, 사진 투고 사이트 등
### 지속률과 관계있는 리포트
* **날짜별 n일 지속률 추이**
  * 지속률을 올릴 수 있는 대책의 효과가 의도한 대로 수행되는지를 확인하려면, 지속률을 날짜에 따라 집계한 리포트를 만들어야한다.
  * 등록 바로 다음 날부터 서비스를 사용하지 않는다면, 이후 습관적으로 서비스를 사용하도록 만들기 어려워질 가능성이 높다. 따라서 서비스를 더 활발하게 하려면 당장 다음 날의 지속률을 높이는 것이 중요
* '로그 최근 일자'와 '사용자별 등록일의 다음날'을 계산하는 쿼리
  ```sql
  with 
	action_log_with_mst_users as(
	select
		u.user_id,
		u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		cast(u.register_date::date + '1 day'::interval as date) as next_day_1
	from mst_users as u
	left join action_log a
	on u.user_id=a.user_id)
	
	
	select * from
	action_log_with_mst_users
	order by register_date
  ```
  * 다음날 지속률을 집계하려면 다음날의 로그 데이터가 모두 쌓여있어야 한다.(등록일 다음날에 작업한 사용자가 정말 0인 경우와 로그가 아직 쌓이지 않아 0명으로 나오는 경우를 구분해야 하기 때문) 따라서, 로그 집계 기간 중에 가장 최신 날짜를 추출하고, 이러한 최신 일자를 넘는 기간의 지속률은 **NULL**로 출력하게 만들어 위와 같은 문제가 될 수 있는 부분을 해결하였다.
* 사용자의 액션 플래그를 계산하는 쿼리
  ```sql
  with 
	action_log_with_mst_users as(
	select
		u.user_id,
		u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		cast(u.register_date::date + '1 day'::interval as date) as next_day_1
	from mst_users as u
	left join action_log a
	on u.user_id=a.user_id),
	
	user_action_flag as (
	select
		user_id,register_date,
		sign(sum(case when next_day_1<=latest_date then
		case when next_day_1=action_date then 1 else 0 end
		end)) as next_1_day_action
	from action_log_with_mst_users
	group by user_id,register_date)
	
	select * from
	user_action_flag
  ```
  * 지정한 날의 다음날에 액션을 했는지 0과 1의 플래그로 표현('지정한 날의 다음날'이 로그의 가장 최근 날짜를 넘는 경우에는 플래그를 NULL로 나타낸다.)
    * 예를 들어, 로그의 최근 날짜가 '2016-11-30'이라면 등록일이 '2016-11-30'인 사용자는 다음날의 액션 플래그가 NULL이 된다.
  * next_1_day_action 구하는 과정
    1. 등록일 다음날이 로그의 최신 날짜 이전인지 확인하기
    2. 등록일 다음날의 날짜에 액션을 했다면 1, 안 했다면 0 지정하기
    3. 사용자별로 등록일 다음날에 한 액션의 합계 구하기
    4. 등록일 다음날에 액션을 했는지 안 했는지를 플래그로 나타내기
* 다음날 지속률을 계산하는 쿼리
  ```sql
  with 
	action_log_with_mst_users as(
	select
		u.user_id,
		u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		cast(u.register_date::date + '1 day'::interval as date) as next_day_1
	from mst_users as u
	left join action_log a
	on u.user_id=a.user_id),
	
	user_action_flag as (
	select
		user_id,register_date,
		sign(sum(case when next_day_1<=latest_date then
		case when next_day_1=action_date then 1 else 0 end
		end)) as next_1_day_action
	from action_log_with_mst_users
	group by user_id,register_date)
	
	select
	register_date,
	avg(100.0*next_1_day_action) as repeat_rate_1_day
	from user_action_flag
	group by register_date
	order by register_date
  ```
  * 0과 1로 표현된 액션플래그를 그래프의 값에 100.0을 곱하고 AVG 함수로 평균을 구해 퍼센트 단위로 나타낸다.

2일째 이후의 지속률을 계산할 경우에도 비슷한 과정을 거친다. action_log_with_mst_users 테이블을 기반으로 등록으로부터 n번째 후의 날짜를 계산하면 된다.                             
하지만 각 지속률 값을 테이블의 컬럼으로 표현하면, 복잡한 쿼리가 되어 관리하기 힘들어진다. 따라서, 지표를 관리하는 일시 테이블을 사용해 각각의 지표를 세로기반으로 표현하는 방법을 통해 이와 같은 문제를 해결 할 수 있다.
* 지속률 지표를 관리하는 마스터 테이블을 작성하는 쿼리
  ```sql
  with
	repeat_interval(index_name,interval_date)as(
	values
	('01 day repeat',1)
	,('02 day repeat',2)
	,('03 day repeat',3)
	,('04 day repeat',4)
	,('05 day repeat',5)
	,('06 day repeat',6)
	,('07 day repeat',7))
	
	select * 
	from repeat_interval
	order by index_name
  ```
  * index_name과 interval_date를 가진 테이블로 변환해서 저장(index_name: 지표의 이름 interval_date: 등록 후의 며칠째 지표인지를 나타낸다.)
* 지속률을 세로 기반으로 집계하는 쿼리
  ```sql
	with
	repeat_interval(index_name,interval_date)as(
	values
	('01 day repeat',1)
	,('02 day repeat',2)
	,('03 day repeat',3)
	,('04 day repeat',4)
	,('05 day repeat',5)
	,('06 day repeat',6)
	,('07 day repeat',7)),
	
	action_log_with_index_date as (
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(cast(u.register_date as date)+ interval '1 day'*r.interval_date as date) as index_date
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as (
	select
		user_id,register_date,index_name,
		sign(sum(case when index_date<=latest_date then
		case when index_date=action_date then 1 else 0 end end)) as index_date_action
	from action_log_with_index_date
	group by user_id,register_date,index_name,index_date)
	
	select
	register_date,index_name,
	avg(100.0*index_date_action) as repeat_rate
	from user_action_flag
	group by register_date,index_name
	order by register_date,index_name
  ```
### 정착률 관련 리포트
#### 매일의 n일 정착률 추이
지속률과 마찬가지로, 대책이 의도한 대로의 효과가 있는지 확인하려면 정착률을 매일 집계한 리포트가 필요하다.                             
(7일 정착률이 극단적으로 낮은 경우에는 정착률이 아니라 '다음날 지속률'~'7일 지속률'을 확인해서 문제를 검토하는 것이 일반적)                            
정착률을 산출할 경우 대상이 되는 기간이 여러 일자에 걸쳐 있으므로 지속률과 같이 마스터 테이블을 작성하는 것이 좋다.
* 정착률 지표를 관리하는 마스터 테이블을 작성하는 쿼리
  ```sql
  with
	repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values
	('07 day retention',1,7),
	('14 day retention',8,14),
	('21 day retention',15,21),
	('28 day retention',22,28))
	
	select *
	from repeat_interval
  ```
* 정착률을 계산하는 쿼리
  ```sql
  with
	repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values
	('07 day retention',1,7),
	('14 day retention',8,14),
	('21 day retention',15,21),
	('28 day retention',22,28)),
	
	action_log_with_index_date as(
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(u.register_date::date+ '1 day'::interval*r.interval_begin_date as date) as index_begin_date,
		cast(u.register_date::date+ '1 day'::interval*r.interval_end_date as date) as index_end_date
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as (
	select
		user_id,register_date,index_name,
		sign(sum(case when index_end_date<=latest_date then
		case when action_date between index_begin_date and index_end_date then 1 else 0 end end)) as index_date_action
	from action_log_with_index_date
	group by user_id,register_date,index_name,index_begin_date,index_end_date)
	
	select
	register_date,index_name,
	avg(100.0*index_date_action) as index_rate
	from user_action_flag
	group by register_date,index_name
	order by register_date,index_name
  ```
#### n일 지속률과 n일 정착률의 추이
**'n일 지속률'** 과 **'n일 정착률'** 을 따로 집계하면, 등록 후 며칠간 사용자가 안정적으로 서비스를 사용하는지, 며칠 후에 서비스를 그만두는 사용자가 많아지는지 등을 알 수 가 있다.                                            
만약 지속률과 정착률이 극단적으로 떨어지는 시점이 있다면, 해당 시점을 기준으로 공지사항 등을 전달하거나 n일 이상 사용자에게 보너스를 주는 등의 대책을 수행해서 지속률과 정착률이 다시 안정적으로 돌아오는 날까지 사용자를 붙잡아 둘 수 있을 것이다.
* 지속률 지표를 관리하는 마스터 테이블을 정착률 형식으로 수정한 쿼리&n일 지속률들을 집계하는 쿼리
  ```sql
  with
	repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values
	('01 day repeat'   ,1, 1),
	('02 day repeat'   ,2, 2),
	('03 day repeat'   ,3, 3),
	('04 day repeat'   ,4, 4),
	('05 day repeat'   ,5, 5),
	('06 day repeat'   ,6, 6),
	('07 day repeat'   ,7, 7),
	('07 day retention',1, 7),
	('14 day retention',8, 14),
	('21 day retention',15, 21),
	('28 day retention',22, 28)),
	
	action_log_with_index_date as(
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(u.register_date::date+ '1 day'::interval*r.interval_begin_date as date) as index_begin_date,
		cast(u.register_date::date+ '1 day'::interval*r.interval_end_date as date) as index_end_date
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as (
	select
		user_id,register_date,index_name,
		sign(sum(case when index_end_date<=latest_date then
		case when action_date between index_begin_date and index_end_date then 1 else 0 end end)) as index_date_action
	from action_log_with_index_date
	group by user_id,register_date,index_name,index_begin_date,index_end_date)
	
	select
	index_name,
	avg(100.0*index_date_action) as repeat_rate
	from 
	user_action_flag
	group by index_name
	order by index_name
  ```
### 원포인트
지속률과 정착률은 모두 등록일 기준으로 n일 후의 행동을 집계하는 것이다. 따라서 등록일로부터 n일 경과하지 않은 상태라면 집계가 불가능하다.                          
따라서, 30일 지속률과 60일 지속률처럼 값을 구하기 위해 시간이 오래 걸리는 지표보다는 1일 지속률, 7일 지속률, 7일 정착률처럼 단기간에 결과를 보고 대책을 세울 수 있는 지표를 활용하는 것이 좋다.                                                                  
                                                   	
추가로 정착률은 7일 동안의 기간을 집계하므로, 실제로 며칠 사용했는지 알 수 없다. 만약 '14일의 정착률 기간 동안 70%의 사용자는 1~2일 정도 사용에 그친다'등을 알고 싶다면 5강 4절을 참고하는 것이 좋다. 
## 3. 지속과 정착에 영향을 주는 액션 집계하기
지속률과 정착률의 추이를 계산해서 사용자의 상황을 이해하는 것도 중요하지만, 무엇 때문에 그러한 추이가 발생하는지 파악하는 것도 중요하다.                       
이러한 지표와 리포트를 만들 때는 **'00율을 올리자'** 처럼 새로운 목표와 과제가 있어야 하고, 그 목표를 위해서 무엇을 해야 할지 구체적인 대책을 제시해야한다.

* 1일 지속률 개선: 등록한 당일 사용자들이 무엇을 했는지 확인
* 14일 정착률 개선: 7일 정착률의 판정 기간 동안 사용자가 어떠한 행동을 했는지 조사
### 1일 지속률 개선을 위한 '등록일의 액션 사용 여부'와 이에 따른 1일 지속률 차이 알아보기
사용자의 1일 지속률이 높고, 비사용자의 1일 지속률이 낮은 액션이 1일 지속률에 더 영향을 준다고 할 수 있다.                         
사용에 영향을 많이 주는 액션의 사용률이 낮다면, 사용자들이 해당 액션을 할 수 있게 설명을 추가하거나 이벤트를 통해 액션 사용을 촉진하고, 사이트의 디자인과 동선 등도 함께 검토해야 한다. 
* 모든 사용자와 액션의 조합을 도출하는 쿼리
  ```sql
  with
	repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values('01 day repeat', 1, 1)),
	
	action_log_with_index_date as (
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(u.register_date::date + '1 day'::interval*r.interval_begin_date as date) as index_begin_date,
		cast(u.register_date::date + '1 day'::interval*r.interval_end_date as date) as index_end_date
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as (
	select
		user_id,register_date,index_name,
		sign(sum(case when index_end_date<=latest_date then
		case when action_date between index_begin_date and index_end_date then 1 else 0 end
		end)) as index_date_action
	from
	action_log_with_index_date
	group by user_id,register_date,index_name,index_begin_date,index_end_date),
	
	mst_actions as (
	select 'view' as action
	union all select 'comment' as action
	union all select 'follow' as action),
	
	mst_user_actions as (
	select
		u.user_id,u.register_date,a.action
	from mst_users as u
	cross join mst_actions as a)
	
	select * from mst_user_actions
	order by user_id,action
  ```
* 사용자의 액션 로그를 0,1플래그로 표현하는 쿼리
  ```sql
  with
	repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values('01 day repeat', 1, 1)),
	
	action_log_with_index_date as (
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(u.register_date::date + '1 day'::interval*r.interval_begin_date as date) as index_begin_date,
		cast(u.register_date::date + '1 day'::interval*r.interval_end_date as date) as index_end_date
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as (
	select
		user_id,register_date,index_name,
		sign(sum(case when index_end_date<=latest_date then
		case when action_date between index_begin_date and index_end_date then 1 else 0 end
		end)) as index_date_action
	from
	action_log_with_index_date
	group by user_id,register_date,index_name,index_begin_date,index_end_date),
	
	mst_actions as (
	select 'view' as action
	union all select 'comment' as action
	union all select 'follow' as action),
	
	mst_user_actions as (
	select
		u.user_id,u.register_date,a.action
	from mst_users as u
	cross join mst_actions as a),
	
	register_action_flag as (
	select
		distinct m.user_id,m.register_date,m.action,
		case
		when a.action is not null then 1 else 0 end as do_action,
		f.index_name,f.index_date_action
	from mst_user_actions as m
	left join action_log as a
	on m.user_id=a.user_id
	and cast(m.register_date as date)=cast(a.stamp as date)
	and m.action=a.action
	left join user_action_flag as f
	on m.user_id=f.user_id
	where f.index_date_action is not null)
	
	select * from register_action_flag
	order by user_id,index_name,action
  ```
  * 각 액션에 대한 사용자와 비사용자의 다음날 지속률을 한꺼번에 계산하기 위해, 모든 사용자와 모든 액션의 조합을 만든 뒤, 사용자의 액션 실행 여부를 0과 1로 나타내는 테이블
* 액션에 따른 지속률과 정착률을 집계하는 쿼리
  ```sql
  with
	repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values('01 day repeat', 1, 1)),
	
	action_log_with_index_date as (
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(u.register_date::date + '1 day'::interval*r.interval_begin_date as date) as index_begin_date,
		cast(u.register_date::date + '1 day'::interval*r.interval_end_date as date) as index_end_date
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as (
	select
		user_id,register_date,index_name,
		sign(sum(case when index_end_date<=latest_date then
		case when action_date between index_begin_date and index_end_date then 1 else 0 end
		end)) as index_date_action
	from
	action_log_with_index_date
	group by user_id,register_date,index_name,index_begin_date,index_end_date),
	
	mst_actions as (
	select 'view' as action
	union all select 'comment' as action
	union all select 'follow' as action),
	
	mst_user_actions as (
	select
		u.user_id,u.register_date,a.action
	from mst_users as u
	cross join mst_actions as a),
	
	register_action_flag as (
	select
		distinct m.user_id,m.register_date,m.action,
		case
		when a.action is not null then 1 else 0 end as do_action,
		f.index_name,f.index_date_action
	from mst_user_actions as m
	left join action_log as a
	on m.user_id=a.user_id
	and cast(m.register_date as date)=cast(a.stamp as date)
	and m.action=a.action
	left join user_action_flag as f
	on m.user_id=f.user_id
	where f.index_date_action is not null)
	
	select
	action,
	count(*) users,
	avg(100.0*do_action) as usage_rate,
	index_name,
	avg(case do_action when 1 then 100.0*index_date_action end) as idx_rate,
	avg(case do_action when 0 then 100.0*index_date_action end) as no_action_idx_rate
	from 
	register_action_flag
	group by index_name,action
	order by index_name,action
  ```
  * 사용자의 액션 로그가 0과 1이라는 플래그로 표현 후, 전제 조건에 따라 비율을 AVG 함수로 구한다.
  * 등록일에 해당 액션을 사용한 사용자는 'do_action=1', 등록일에 해당 액션을 사용하지 않은 사용자는 'do_action=0'으로 구분된다.
  * 위와 같은 사용자와 비사용자를 기반으로 index_date_action의 평균을 구ㅖ산하면 1일 지속률을 구할 수 있다.
### 원포인트
* 특정 액션의 실행이 지속률과 정착률 상승으로 이어질 것으로 보여도, 해당 액션을 실행하는 진입 장벽이 높다면, 지속률과 정착률에 영향을 조금 주더라도 액션을 실햏아는 진입 장벽이 낮은 액션을 기반으로 대책을 세우는 것이 좋다.(e.g. 동영상 업로드보다는 이미지 업로드 촉진하기)
## 4. 액션 수에 따른 정착률 집계하기
* **대표적인 SNS사례**
  * '등록 후 1주일 이내에 10명을 팔로우하면, 해당 사용자는 서비스를 계속해서 사용한다'
    * 서비스 활성화를 유도하기 위해 '알 수도 있는 사람', '00님을 함께 알고 있습니다'를 화면에 출력하게 만들거나, 인기 사용자를 팔로우하는 튜토리얼을 만든다.
### 등록일과 이후 7일 정착률 기간에 실행한 액션 수가 14일 정착률에 어떻게 변화하는지 알아보기
* 액션의 계급 마스터와 사용자ㅇ 액션 플래그의 조합을 산출하기
  ```sql
  with repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values('14 day retention', 8, 14)),
	
	action_log_with_index_date as (
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(u.register_date::date + '1 day'::interval*r.interval_begin_date as date) as index_begin_date,
		cast(u.register_date::date + '1 day'::interval*r.interval_end_date as date) as index_end_date
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as(
	select
		user_id,register_date,index_name,
		sign(sum(case 
		when index_end_date<=latest_date then
		case 
		when action_date between index_begin_date and index_end_date then 1 else 0 end
		end)) as index_date_action
	from action_log_with_index_date
	group by user_id,register_date,index_name,index_begin_date,index_end_date),
	
	mst_action_bucket(action,min_count,max_count) as (
	values
	('comment', 0, 0),
	('comment', 1, 5),
	('comment', 6, 10),
	('comment', 11, 9999),
	('follow', 0, 0),
	('follow', 1, 5),
	('follow', 6, 10),
	('follow', 11, 9999)),
	
	mst_users_action_bucket as (
	select
		u.user_id,
		u.register_date,
		a.action,
		a.min_count,
		a.max_count
	from mst_users as u
	cross join mst_action_bucket as a)
	
	select * from mst_users_action_bucket
	order by user_id,action,min_count
  ```
  * 액션 단계 마스터를 일시 테이블로 정의, CROSS JOIN을 사용하여 사용자와 액션 조합을 만들기
* 등록 후 7일 동안의 액션 수를 집계
  ```sql
  with repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values('14 day retention', 8, 14)),
	
	action_log_with_index_date as (
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(u.register_date::date + '1 day'::interval*r.interval_begin_date as date) as index_begin_date,
		cast(u.register_date::date + '1 day'::interval*r.interval_end_date as date) as index_end_date
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as(
	select
		user_id,register_date,index_name,
		sign(sum(case 
		when index_end_date<=latest_date then
		case 
		when action_date between index_begin_date and index_end_date then 1 else 0 end
		end)) as index_date_action
	from action_log_with_index_date
	group by user_id,register_date,index_name,index_begin_date,index_end_date),
	
	mst_action_bucket(action,min_count,max_count) as (
	values
	('comment', 0, 0),
	('comment', 1, 5),
	('comment', 6, 10),
	('comment', 11, 9999),
	('follow', 0, 0),
	('follow', 1, 5),
	('follow', 6, 10),
	('follow', 11, 9999)),
	
	mst_users_action_bucket as (
	select
		u.user_id,
		u.register_date,
		a.action,
		a.min_count,
		a.max_count
	from mst_users as u
	cross join mst_action_bucket as a),
	
	register_action_flag as (
	select
		m.user_id,m.action,m.min_count,m.max_count,count(a.action) as action_count,
		case
		when count(a.action) between m.min_count and m.max_count then 1 else 0 end as achieve,
		index_name,index_date_action
	from mst_users_action_bucket as m
	left join action_log a
	on m.user_id=a.user_id
	and cast(a.stamp as date) between cast(m.register_date as date) and cast(m.register_date as date)+interval '7 days'
	and m.action=a.action
	left join user_action_flag as f
	on m.user_id=f.user_id
	where f.index_date_action is not null
	group by m.user_id,m.action,m.min_count,m.max_count,f.index_name,f.index_date_action)
	
	
	select *
	from register_action_flag
	order by user_id,action,min_count
  ```
  * 위 코드 출력 결과에 등록 후 7일 동안의 로그를 left join, 등록 후 7일 동안의 액션 수 집계
 * 등록 후 7일 동안의 액션 횟수별로 14일 정착률을 집계하는 쿼리
   ```sql
   with repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values('14 day retention', 8, 14)),
	
	action_log_with_index_date as (
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(u.register_date::date + '1 day'::interval*r.interval_begin_date as date) as index_begin_date,
		cast(u.register_date::date + '1 day'::interval*r.interval_end_date as date) as index_end_date
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as(
	select
		user_id,register_date,index_name,
		sign(sum(case 
		when index_end_date<=latest_date then
		case 
		when action_date between index_begin_date and index_end_date then 1 else 0 end
		end)) as index_date_action
	from action_log_with_index_date
	group by user_id,register_date,index_name,index_begin_date,index_end_date),
	
	mst_action_bucket(action,min_count,max_count) as (
	values
	('comment', 0, 0),
	('comment', 1, 5),
	('comment', 6, 10),
	('comment', 11, 9999),
	('follow', 0, 0),
	('follow', 1, 5),
	('follow', 6, 10),
	('follow', 11, 9999)),
	
	mst_users_action_bucket as (
	select
		u.user_id,
		u.register_date,
		a.action,
		a.min_count,
		a.max_count
	from mst_users as u
	cross join mst_action_bucket as a),
	
	register_action_flag as (
	select
		m.user_id,m.action,m.min_count,m.max_count,count(a.action) as action_count,
		case
		when count(a.action) between m.min_count and m.max_count then 1 else 0 end as achieve,
		index_name,index_date_action
	from mst_users_action_bucket as m
	left join action_log a
	on m.user_id=a.user_id
	and cast(a.stamp as date) between cast(m.register_date as date) and cast(m.register_date as date)+interval '7 days'
	and m.action=a.action
	left join user_action_flag as f
	on m.user_id=f.user_id
	where f.index_date_action is not null
	group by m.user_id,m.action,m.min_count,m.max_count,f.index_name,f.index_date_action)
	
	select
	action,
	concat(min_count, '~', max_count) as count_range,
	sum(case achieve when 1 then 1 else 0 end) as acheive,
	index_name,
	avg(case achieve when 1 then 100.0*index_date_action end) as achieve_index_rate
	from register_action_flag
	group by index_name,action,min_count,max_count
	order by index_name,action,min_count
   ```
## 5. 사용 일수에 따른 정착률 집계하기
7일 정착 기간 동안 사용자의 이용일수가 이후 정착률에 어떠한 영향을 주는지 확인하는 것
* 특정 날짜에 등록한 사용자가 '등록 다음날부터 7일 중에 며칠을 사용했는지'를 집계하고, '28일 정착률'을 집계한뒤 리포트 만들기
  * 등록일 다음날부터 7일 동안의 사용 일수를 집계
  * 사용 일수별로 집계한 사용자 수의 구성비와 구성비누계를 계산
  * 사용 일수별로 집계한 사용자 수를 분모로 두고, 28일 정착률을 집계한 뒤 그 비율을 계산
* 등록일 다음날부터의 7일 동안의 사용 일수와 28일 정착 플래그를 생성
  ```sql
  with
	repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values('28 day retention', 22 , 28)),
	
	action_log_with_index_date as(
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(u.register_date::date+'1 day'::interval*r.interval_begin_date as date) as index_begin_date,
		cast(u.register_date::date+'1 day'::interval*r.interval_end_date as date) as index_end_date 
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as(
	select
		user_id,register_date,index_name,
		sign(sum(case when index_end_date<=latest_date then
		case when action_date between index_begin_date and index_end_date then 1 else 0 end end)) as index_date_action
	from action_log_with_index_date
	group by user_id,register_date,index_name,index_begin_date,index_end_date),
	
	register_action_flag as(
	select
		m.user_id,
		count(distinct cast(a.stamp as date)) as dt_count,
		index_name,index_date_action
	from mst_users as m
	left join action_log as a
	on m.user_id=a.user_id
	and cast(a.stamp as date) between cast(m.register_date as date)+ interval '1 day' and cast(m.register_date as date)+ interval '8 days'
	left join user_action_flag as f
	on m.user_id=f.user_id
	where f.index_date_action is not null
	group by m.user_id,f.index_name,f.index_date_action)
	
	select * from register_action_flag
  ```
  * 정착률 지표 마스터 작성 후, 내부에 user_action_flag 집계
  * 이후, 사용자 마스터에 등록일 다음날부터 7일 이내의 액션 로그를 결합하고, 해당 기간의 사용 일수를 카운트
* 사용 일수에 따른 정착율을 집계
  ```sql
  with
	repeat_interval(index_name,interval_begin_date,interval_end_date) as (
	values('28 day retention', 22 , 28)),
	
	action_log_with_index_date as(
	select
		u.user_id,u.register_date,
		cast(a.stamp as date) as action_date,
		max(cast(a.stamp as date)) over() as latest_date,
		r.index_name,
		cast(u.register_date::date+'1 day'::interval*r.interval_begin_date as date) as index_begin_date,
		cast(u.register_date::date+'1 day'::interval*r.interval_end_date as date) as index_end_date 
	from mst_users as u
	left join action_log as a
	on u.user_id=a.user_id
	cross join repeat_interval as r),
	
	user_action_flag as(
	select
		user_id,register_date,index_name,
		sign(sum(case when index_end_date<=latest_date then
		case when action_date between index_begin_date and index_end_date then 1 else 0 end end)) as index_date_action
	from action_log_with_index_date
	group by user_id,register_date,index_name,index_begin_date,index_end_date),
	
	register_action_flag as(
	select
		m.user_id,
		count(distinct cast(a.stamp as date)) as dt_count,
		index_name,index_date_action
	from mst_users as m
	left join action_log as a
	on m.user_id=a.user_id
	and cast(a.stamp as date) between cast(m.register_date as date)+ interval '1 day' and cast(m.register_date as date)+ interval '8 days'
	left join user_action_flag as f
	on m.user_id=f.user_id
	where f.index_date_action is not null
	group by m.user_id,f.index_name,f.index_date_action)
	
	select
	dt_count as dates,
	count(user_id) as users,
	100.0*count(user_id)/sum(count(user_id)) over() as user_ratio,
	100.0*sum(count(user_id)) over(order by index_name,dt_count rows between unbounded preceding and current row)/
	sum(count(user_id)) over() as cum_ratio,
	sum(index_date_action) as achieve_ratio,
	avg(100.0*index_date_action) as achieve_ratio
	from register_action_flag
	group by index_name,dt_count
	order by index_name,dt_count
  ```
  * 앞선 결과를 사용 일수별로 집약해서 사용 일수에 따른 정착율 집계
## 6. 사용자의 잔존율 집계하기
서비스 등록 수개월 후, 어느 정도 비율의 사용자가 서비스를 지속해서 사용하는지 대략적으로 파악해두면, 서비스에 어떤 문제가 있는지 찾아내거나, 과거와 현재를 비교하고 미래 목표에 대한 전망을 검토할 수 있다.
* 12개월 후까지의 월을 도출하기 위한 보조 테이블 만들기
  ```sql
	  with
		mst_intervals(interval_month) as (
		values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12))
		
		select * from mst_intervals
	  ```
	* 등록 월에서 12개월 후까지의 잔존율을 집계하는 쿼리
	  ```sql
	  with
	mst_intervals(interval_month) as (
	values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12)),
	
	mst_users_with_index_month as (
	select
		u.user_id,u.register_date,
		cast(u.register_date::date+i.interval_month*'1 month'::interval as date) as index_date,
		substring(u.register_date,1,7) as register_month,
		substring(cast(u.register_date::date+i.interval_month*'1 month'::interval as text),1,7) as index_month
	from mst_users as u
	cross join mst_intervals as i),
	
	action_log_in_month as (
	select
		user_id,
		substring(stamp,1,7) as action_month
	from action_log)
	
	select
	u.register_month,u.index_month,
	sum(case when a.action_month is not null then 1 else 0 end) as users,
	avg(case when a.action_month is not null then 100.0 else 0.0 end) as retension_rate
	from mst_users_with_index_month as u
	left join action_log_in_month as a
	on u.user_id=a.user_id
	and u.index_month=a.action_month
	group by u.register_month,u.index_month
  ```
  * 앞선 보조 테이블을 사용해 사용자의 등록일부터 12개월 후까지의 월을 사용자 마스터에 추가
  * 액션 로그의 로그 날짜를 월 단위 표현으로 변경하고, 등록 월부터 12개월 후 까지의 월을 추가한 사용자 마스터와 결합하여 월 단위의 잔존율을 집계
## 7. 방문 빈도를 기반으로 사용자 속성을 정의하고 집계하기
### MAU(Monthly Active Users)
#### MAU를 3개로 나누어 분석하기
* 신규 사용자
* 리피트 사용자
* 컴백 사용자
****
* 신규 사용자 수, 리피트 사용자 수, 컴백 사용자 수를 집계
  ```sql
	  with
	monthly_user_action as (
	select
		u.user_id,
		substring(u.register_date,1,7) as register_month,
		substring(l.stamp,1,7) as action_month,
		substring(cast(l.stamp::date-interval '1 month' as text),1,7) as action_month_priv
	from mst_users as u
	join action_log as l
	on u.user_id=l.user_id),
	
	monthly_user_with_type as (
	select
		action_month,user_id,
		case
		when register_month=action_month then 'new_user'
		when action_month_priv=lag(action_month) over(partition by user_id order by action_month) then 'repeat_user'
		else 'come_back_user' end as c,
		action_month_priv
	from monthly_user_action)
	
	select
	action_month,
	count(user_id) as mau,
	count(case when c='new_user' then 1 end) as new_users,
	count(case when c='repeat_user' then 1 end) as repeat_users,
	count(case when c='come_back_user' then 1 end) as come_back_users
	from 
	monthly_user_with_type
	group by action_month
	order by action_month
  ```
#### 리피트 사용자를 3가지로 분류하기
* 신규 리피트 사용자
* 기존 리피트 사용자
* 컴백 리피트 사용자
****
* 리피트 사용자를 세분화해서 집계
  ```sql
	  with
	monthly_user_action as (
	select
		u.user_id,
		substring(u.register_date,1,7) as register_month,
		substring(l.stamp,1,7) as action_month,
		substring(cast(l.stamp::date-interval '1 month' as text),1,7) as action_month_priv
	from mst_users as u
	join action_log as l
	on u.user_id=l.user_id),
	
	monthly_user_with_type as (
	select
		action_month,user_id,
		case
		when register_month=action_month then 'new_user'
		when action_month_priv=lag(action_month) over(partition by user_id order by action_month) then 'repeat_user'
		else 'come_back_user' end as c,
		action_month_priv
	from monthly_user_action),
	
	monthly_users as (
	select
		m1.action_month,
		count(m1.user_id) as mau,
		count(case when m1.c='new_user' then 1 end) as new_users,
		count(case when m1.c='repeat_user' then 1 end) as repeat_users,
		count(case when m1.c='come_back_user' then 1 end) as come_back_users,
		count(case when m1.c='repeat_user' and m0.c='new_user' then 1 end) as new_repeat_users,
		count(case when m1.c='repeat_user' and m0.c='repeat_user' then 1 end) as continuous_repeat_users,
		count(case when m1.c='repeat_user' and m0.c='come_back_user' then 1 end) as come_back_repeat_user
	from monthly_user_with_type as m1
	left join monthly_user_with_type as m0
	on m1.user_id=m0.user_id
	and m1.action_month_priv=m0.action_month
	group by m1.action_month)
	
	select * from monthly_users
	order by action_month
  ```
### MAU 속성별 반복률 계산하기
* MAU 내역과 MAU 속성들의 반복률 계산
  ```sql
	  with
	monthly_user_action as (
	select
		u.user_id,
		substring(u.register_date,1,7) as register_month,
		substring(l.stamp,1,7) as action_month,
		substring(cast(l.stamp::date-interval '1 month' as text),1,7) as action_month_priv
	from mst_users as u
	join action_log as l
	on u.user_id=l.user_id),
	
	monthly_user_with_type as (
	select
		action_month,user_id,
		case
		when register_month=action_month then 'new_user'
		when action_month_priv=lag(action_month) over(partition by user_id order by action_month) then 'repeat_user'
		else 'come_back_user' end as c,
		action_month_priv
	from monthly_user_action),
	
	monthly_users as (
	select
		m1.action_month,
		count(m1.user_id) as mau,
		count(case when m1.c='new_user' then 1 end) as new_users,
		count(case when m1.c='repeat_user' then 1 end) as repeat_users,
		count(case when m1.c='come_back_user' then 1 end) as come_back_users,
		count(case when m1.c='repeat_user' and m0.c='new_user' then 1 end) as new_repeat_users,
		count(case when m1.c='repeat_user' and m0.c='repeat_user' then 1 end) as continuous_repeat_users,
		count(case when m1.c='repeat_user' and m0.c='come_back_user' then 1 end) as come_back_repeat_user
	from monthly_user_with_type as m1
	left join monthly_user_with_type as m0
	on m1.user_id=m0.user_id
	and m1.action_month_priv=m0.action_month
	group by m1.action_month)
	
	select
	actioin_month,mau,new_users,repeat_users,come_back_users,new_repeat_users,continous_repeat_users,come_back_repeat_users,
	100.0*new_repeat_users/nullif(lag(new_users) over (order by action_month),0) as priv_new_repeat_ratio,
	100.0*continuous_repeat_users/nullif(lag(repeat_users) over (order by action_month),0) as priv_continuous_repeat_ratio,
	100.0*come_back_repeat_users/nullif(lag(come_back_users) over (order by action_month),0) as priv_come_back_repeat_ratio
	from monthly_users
	order by action_month
  ```
## 8. 방문 종류를 기반으로 성장지수 집계하기
* 성장지수 산출을 위해 사용자 상태 집계
  ```sql
  with
	unique_action_log as(
	select
		distinct user_id,
		substring(stamp,1,10) as action_date
	from action_log),
	
	mst_calendar as(
	select '2016-10-01' as dt
	union all select '2016-10-02' as dt
	union all select '2016-10-03' as dt
	union all select '2016-11-04' as dt)
	,
	
	target_date_with_user as (
	select
		c.dt as target_date,
		u.user_id,u.register_date,u.withdraw_date
	from mst_users as u
	cross join mst_calendar as c),
	
	user_status_log as (
	select
		u.target_date,u.user_id,u.register_date,a.action_date,
		case when u.register_date=a.action_date then 1 else 0 end as is_new,
		case when u.withdraw_date=a.action_date then 1 else 0 end as is_exit,
		case when u.target_date=a.action_date then 1 else 0 end as is_access,
		lag(case when u.target_date=a.action_date then 1 else 0 end)
		over(partition by u.user_id order by u.target_date) as was_access
	from target_date_with_user as u
	left join unique_action_log as a
	on u.user_id=a.user_id and u.target_date=a.action_date
	where u.register_date<=u.target_date
	and (u.withdraw_date is null or u.target_date<=u.withdraw_date)
	)
  ```
* 매일의 성장지수 계산
  ```sql
	with
	unique_action_log as(
	select
		distinct user_id,
		substring(stamp,1,10) as action_date
	from action_log),
	
	mst_calendar as(
	select '2016-10-01' as dt
	union all select '2016-10-02' as dt
	union all select '2016-10-03' as dt
	union all select '2016-11-04' as dt)
	,
	
	target_date_with_user as (
	select
		c.dt as target_date,
		u.user_id,u.register_date,u.withdraw_date
	from mst_users as u
	cross join mst_calendar as c),
	
	user_status_log as (
	select
		u.target_date,u.user_id,u.register_date,a.action_date,
		case when u.register_date=a.action_date then 1 else 0 end as is_new,
		case when u.withdraw_date=a.action_date then 1 else 0 end as is_exit,
		case when u.target_date=a.action_date then 1 else 0 end as is_access,
		lag(case when u.target_date=a.action_date then 1 else 0 end)
		over(partition by u.user_id order by u.target_date) as was_access
	from target_date_with_user as u
	left join unique_action_log as a
	on u.user_id=a.user_id and u.target_date=a.action_date
	where u.register_date<=u.target_date
	and (u.withdraw_date is null or u.target_date<=u.withdraw_date)
	),
	
	user_growth_index as(
	select
		*,
		case
		--- 어떤 날짜에 신규 등록 또는 탈퇴한 경우 signup 또는 exit으로 판정하기
		when is_new+is_exit=1 then
		case when is_new=1 then 'signup' when is_exit=1 then 'exit' end
		--- 신규 등록과 탈퇴가 아닌 경우 reactivation 또는 deactivation으로 판정하기
		--- 이때 reactivation, deactivation 정의에 맞지 않은 경우 null로 지정
		when is_new+is_exit=0 then
		case 
		when was_access=0 and is_access=1 then 'reactivation'
		when was_access=1 and is_access=0 then 'deactivation' end end as growth_index
		--- 어떤 날짜에 신규 등록과 탈퇴를 함께 했다면(is_new+is_exit=2) null로 지정
	from user_status_log)
	
	select
	target_date,
	sum(case growth_index when 'signup' then 1 else 0 end) as signup,
	sum(case growth_index when 'reactivation' then 1 else 0 end) as reactivation,
	sum(case growth_index when 'deactivation' then -1 else 0 end) as deactivation,
	sum(case growth_index when 'exit' then -1 else 0 end) as exit,
	sum(case growth_index
	   when 'signup' then 1
	   when 'reactivation' then 1
	   when 'deactivation' then -1
	   when 'exit' then -1
	   else 0
	   end) as growth_index
	from 
	user_growth_index
	group by target_date
	order by target_date
  ```
# 13강 시계열에 따른 사용자의 개별적인 행동 분석하기
## 1. 사용자의 액션 간격 집계하기
### 같은 레코드에 있는 두 개의 날짜로 계산할 경우
* 신청일과 숙박일의 리드 타임을 계산하는 쿼리
  ```sql
	  with
	reservations(reservation_id,register_date,visit_date,days) as(
	values
	(1,date '2016-09-01',date '2016-10-01', 3),
	(2,date '2016-09-20',date '2016-10-01', 2),
	(3,date '2016-09-30',date '2016-11-20', 2),
	(4,date '2016-10-01',date '2017-01-03', 2),
	(5,date '2016-11-01',date '2016-12-28', 3))
	
	우
  ```
  * 날짜끼리 빼거나 **datediff**함수를 써서 각 날짜의 차이를 계산
### 여러 테이블에 있는 여러 개의 날짜로 계산할 경우
* 각 단계에서의 리드 타임과 토탈 리드 타임을 계산하는 쿼리
  ```sql
	  with
	requests(user_id,product_id,request_date) as(
	values
	('U001','1',date '2016-09-01'),
	('U001','2',date '2016-09-20'),
	('U001','3',date '2016-09-30'),
	('U003','4',date '2016-10-01'),
	('U004','5',date '2016-11-01')),
	
	estimates(user_id,product_id,estimate_date) as(
	values
	('U001','2',date '2016-09-21'),
	('U002','3',date '2016-10-15'),
	('U003','4',date '2016-10-15'),
	('U004','5',date '2016-12-01')),
	
	orders(user_id,product_id,order_date) as (
	values
	('U001','2',date '2016-10-01'),
	('U004','5',date '2016-12-05'))
	
	select
	r.user_id,r.product_id,
	e.estimate_date::date-r.request_date::date as estimate_lead_time,
	o.order_date::date-e.estimate_date::date as order_lead_time,
	o.order_date::date-r.request_date::date as total_lead_time
	from requests as r
	left join estimates as e
	on r.user_id=e.user_id and r.product_id=e.product_id
	left join orders as o
	on r.user_id=o.user_id and r.product_id=o.product_id
  ```
  * 여러 개의 테이블에 있는 날짜를 참조할 수 있도록 테이블을 **JOIN**하고, 이전과 같은 방법으로 날짜의 차이를 계산
### 같은 테이블의 다른 레코드에 있는 날짜로 계산할 경우
* 이전 구매일로부터의 일수를 계산하는 쿼리
  ```sql
	  with
	purchace_log(user_id,product_id,purchase_date) as(
	values
	('U001','1','2016-09-01'),
	('U001','2','2016-09-20'),
	('U002','3','2016-09-30'),
	('U001','4','2016-10-01'),
	('U002','5','2016-11-01'))
	
	select
	user_id,purchase_date,
	purchase_date::date-lag(purchase_date::date) over (partition by user_id order by purchase_date) as lead_time
	from purchace_log
  ```
  * **LAG** 함수를 사용해 날짜의 차이 계산
## 2. 카트 추가 후에 구매했는지 파악
* 상품들이 카트에 추가된 시각과 구매된 시각을 산출
  ```sql
	  with 
	row_action_log as(
	select
		dt,user_id,action,
		regexp_split_to_table(products,',') as product_id,
		stamp
	from action_log),
	
	action_time_stats as(
	select
		user_id,product_id,
		min(case action when 'add_cart' then dt end) as dt,
		min(case action when 'add_cart' then stamp end) as add_cart_time,
		min(case action when 'purchase' then stamp end) as purchase_time,
		extract(epoch from
			   min(case action when 'purchase' then stamp::timestamp end)-
			   min(case action when 'add_cart' then stamp::timestamp end)) as lead_time
	from row_action_log
	group by user_id,product_id)
	
	select
	user_id,product_id,add_cart_time,purchase_time,lead_time
	from action_time_stats
	order by user_id,product_id
  ```
* 카트 추가 후 n시간 이내에 구매된 상품 수와 구매율 집계
  ```sql
	  with 
	row_action_log as(
	select
		dt,user_id,action,
		regexp_split_to_table(products,',') as product_id,
		stamp
	from action_log),
	
	action_time_stats as(
	select
		user_id,product_id,
		min(case action when 'add_cart' then dt end) as dt,
		min(case action when 'add_cart' then stamp end) as add_cart_time,
		min(case action when 'purchase' then stamp end) as purchase_time,
		extract(epoch from
			   min(case action when 'purchase' then stamp::timestamp end)-
			   min(case action when 'add_cart' then stamp::timestamp end)) as lead_time
	from row_action_log
	group by user_id,product_id),
	
	purchase_lead_time_flag as(
	select
		user_id,
		product_id,
		dt,
		case when lead_time<=1*60*60 then 1 else 0 end as purchase_1_hour,
		case when lead_time<=6*60*60 then 1 else 0 end as purchase_6_hours,
		case when lead_time<=24*60*60 then 1 else 0 end as purchase_24_hours,
		case when lead_time<=48*60*60 then 1 else 0 end as purchase_48_hours,
		case when lead_time is null or not(lead_time<=48*60*60) then 1 else 0 end as not_purchase
	from action_time_stats)
	
	select
	dt,
	count(*) as add_cart,
	sum(purchase_1_hour) as purchase_1_hour,
	avg(purchase_1_hour) as purchase_1_hour_rate,
	sum(purchase_6_hours) as purchase_6_hours,
	avg(purchase_6_hours) as purchase_6_hours_rate,
	sum(purchase_24_hours) as purchase_24_hours,
	avg(purchase_24_hours) as purchase_24_hours_rate,
	sum(purchase_48_hours) as purchase_48_hours,
	avg(purchase_48_hours) as purchase_48_hours_rate,
	sum(not_purchase) as not_purchase,
	avg(not_purchase) as not_purchase_rate
	from purchase_lead_time_flag
	group by dt
  ```
			

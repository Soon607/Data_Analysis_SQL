# 14강 사이트 전체의 특징/경향 찾기
## 1. 날짜별 방문자 수/방문 횟수/페이지 뷰 집계하기
* 지표 정의
  * 방문자 수: 브라우저를 꺼도 사라지지 않는 쿠키의 유니크 수
  * 방문 횟수: 브라우저를 껐을 때 사라지는 쿠키의 유니크 수
  * 페이지 뷰: 페이지를 출력한 로그의 줄 수
* 날짜별 접근 데이터를 집계하는 쿼리
  ```sql
  select
  substring(stamp,1,10) as dt,
  count(distinct long_session) as access_users,
  count(distinct short_session) as access_count,
  count(*) as page_view,
  1.0*count(*)/nullif(count(distinct long_session),0) as pv_per_user
  from access_log
  group by substring(stamp,1,10)
  order by dt
  ```
## 2. 페이지별 쿠키/방문 횟수/페이지 뷰 집계하기
### URL별로 집계하기
* URL별로 집계하는 쿼리
  ```sql
  select
  url,
  count(distinct short_session) as access_count,
  count(distinct long_session) as access_users,
  count(*) as page_view
  from access_log
  group by access_log
  ```
### 경로별로 집계하기
'/detail?id=**'을 '상세 페이지'라고 집계할 수 있게, 요청 매개변수를 생략하고 경로만으로 집계하기
* 경로별로 집계하는 쿼리
  ```sql
    with
  access_log_with_path as(
  select
  	*,
  	substring(url from'//[^/]+([^?#]+)') as url_path
  from access_log)
  
  select
  url_path,
  count(distinct short_session) as access_count,
  count(distinct long_session) as access_users,
  count(*) as page_view
  from
  access_log_with_path
  group by url_path
  ```
  ### URL에 의미를 부여해서 집계하기
  * URL에 의미를 부여해서 집계하는 쿼리
    ```sql
        with
    access_log_with_path as(
    select
    	*,
    	substring(url from'//[^/]+([^?#]+)') as url_path
    from access_log),
    
    access_log_with_split_path as (
    select
    	*,
    	split_part(url_path,'/',2) as path1,
    	split_part(url_path,'/',3) as path2
    from access_log_with_path),
    
    access_log_with_page_name as(
    select
    	*,
    	case when path1='list' then 
    	case when path2='newly' then 'newly_list'
    	else 'category_list' end
    	else url_path
    	end as page_name
    from access_log_with_split_path)
    
    select
    page_name,
    count(distinct short_session) as access_count,
    count(distinct long_session) as access_users,
    count(*) as page_view
    from access_log_with_page_name
    group by page_name
    order by page_name
  ```
## 3. 유입원별로 방문 횟수 또는 CVR 집계하기
### 유입원별 방문 횟수 집계하기
* 유입원별로 방문 횟수를 집계하는 쿼리
  ```sql
    with
  access_log_with_parse_info as (
  select
  	*,
  	substring(url from 'https?://([^/]*)') as url_domain,
  	substring(url from 'utm_source=([^&]*)') as url_utm_source,
  	substring(url from 'utm_medium=([^&]*)') as url_utm_medium,
  	substring(referrer from 'https?://([^/]*)') as referrer_domain
  from access_log),
  
  access_log_with_via_info as (
  select *,
  	row_number() over(order by stamp) as log_id,
  	case
  	when url_utm_source<>'' and url_utm_medium<>''
  	then concat(url_utm_source,'-',url_utm_medium)
  	when referrer_domain in ('search.yahoo.co.jp','www.google.co.jp') then 'search'
  	when referrer_domain in ('twitter.com','www.facebook.com') then 'social'
  	else 'other'
  	end as via
  from access_log_with_parse_info
  where coalesce(referrer_domain,'') not in ('',url_domain))
  
  select
  via,
  count(*) as access_count
  from access_log_with_via_info
  group by via
  order by access_count desc
  ```
### 유입원별로 CVR 집계하기
* 각 방문에서 구매한 비율(CVR)을 집계하는 쿼리
  ```sql
    with
  access_log_with_parse_info as (
  select
  	*,
  	substring(url from 'https?://([^/]*)') as url_domain,
  	substring(url from 'utm_source=([^&]*)') as url_utm_source,
  	substring(url from 'utm_medium=([^&]*)') as url_utm_medium,
  	substring(referrer from 'https?://([^/]*)') as referrer_domain
  from access_log),
  
  access_log_with_via_info as (
  select *,
  	row_number() over(order by stamp) as log_id,
  	case
  	when url_utm_source<>'' and url_utm_medium<>''
  	then concat(url_utm_source,'-',url_utm_medium)
  	when referrer_domain in ('search.yahoo.co.jp','www.google.co.jp') then 'search'
  	when referrer_domain in ('twitter.com','www.facebook.com') then 'social'
  	else 'other'
  	end as via
  from access_log_with_parse_info
  where coalesce(referrer_domain,'') not in ('',url_domain)),
  
  access_log_with_purchase_amount as(
  select
  	a.log_id,a.via,
  	sum(
  	case when p.stamp::date between a.stamp::date and a.stamp::date+'1 day'::interval
  	then amount end) as amount
  from 
  access_log_with_via_info as a
  left join purchase_log as p
  on a.long_session=p.long_session
  group by a.log_id,a.via)
  
  select
  via,
  count(*) as via_count,
  count(amount) as conversions,
  avg(100.0*sign(coalesce(amount,0))) as cvr,
  sum(coalesce(amount,0)) as amount,
  avg(1.0*coalesce(amount,0)) avg_amount
  from 
  access_log_with_purchase_amount
  group by via
  order by cvr desc
  ```
## 4. 접근 요일, 시간대 파악하기
* 요일/시간대별 방문자 수를 집계하는 쿼리
  ```sql
    with
  access_log_with_dow as (
  select
  	stamp,
  	date_part('dow',stamp::timestamp) as dow,
  	cast(substring(stamp,12,2) as int)*60*60
  	+cast(substring(stamp,15,2) as int)*60
  	+cast(substring(stamp,18,2) as int)
  	as whole_seconds,
  	30*60 as interval_seconds
  from access_log),
  
  access_log_with_floor_seconds as (
  select
  	stamp,
  	dow,
  	cast((floor(whole_seconds/interval_seconds)*interval_seconds) as int) as floor_seconds
  from access_log_with_dow),
  
  access_log_with_index as (
  select
  	stamp,
  	dow,
  	concat(
  		lpad(floor(floor_seconds/(60*60))::text,2,'0'),':',
  	lpad(floor(floor_seconds%(60*60)/60)::text,2,'0'),':',
  	lpad(floor(floor_seconds%60)::text,2,'0')) as index_time
  from access_log_with_floor_seconds)
  
  select
  index_time,
  count(case dow when 0 then 1 end) as sun,
  count(case dow when 1 then 1 end) as mon,
  count(case dow when 2 then 1 end) as tue,
  count(case dow when 3 then 1 end) as wed,
  count(case dow when 4 then 1 end) as thu,
  count(case dow when 5 then 1 end) as fri,
  count(case dow when 6 then 1 end) as sat
  from access_log_with_index
  group by index_time
  ```
# 15강 사이트 내의 사용자 행동 파악하기
## 1. 입구 페이지와 출구 페이지 파악하기
### 입구 페이지와 출구 페이지 집계하기
* 각 세션의 입구 페이지와 출구 페이지 경로를 추출
  ```sql
  with
   activity_log_with_landing_exit as(
   select
   	session,
   	path,
   	stamp,
   	first_value(path)
   	over(partition by session
   		order by stamp asc
   		rows between unbounded preceding and unbounded following) as landing,
   	last_value(path)
   	over(partition by session
   		order by stamp asc
   		rows between unbounded preceding and unbounded following) as exit
   from activity_log)
   
   select *
   from activity_log_with_landing_exit
   ```
* 각 세션의 입구 페이지와 출구 페이지를 기반으로 방문 횟수를 추출하는 쿼리
  ```sql
   with
  activity_log_with_landing_exit as(
  select
  	session,
  	path,
  	stamp,
  	first_value(path)
  	over(partition by session
  		order by stamp asc
  		rows between unbounded preceding and unbounded following) as landing,
  	last_value(path)
  	over(partition by session
  		order by stamp asc
  		rows between unbounded preceding and unbounded following) as exit
  from activity_log),
  
  landing_count as (
  select
  	landing as path,
  	count(distinct session) as count
  from activity_log_with_landing_exit
  group by landing),
  
  exit_count as (
  select
  	exit as path,
  	count(distinct session) as count
  from activity_log_with_landing_exit
  group by exit)
  
  select 'landing' as type, * from landing_count
  union all
  select 'exit' as type, * from exit_count
  ```
### 어디에서 조회를 시작해서, 어디에서 이탈하는지 집계하기  
* 세션별 입구 페이지와 출구 페이지의 조합을 집계하는 쿼리
  ```sql
    with
  activity_log_with_landing_exit as(
  select
  	session,
  	path,
  	stamp,
  	first_value(path)
  	over(partition by session
  		order by stamp asc
  		rows between unbounded preceding and unbounded following) as landing,
  	last_value(path)
  	over(partition by session
  		order by stamp asc
  		rows between unbounded preceding and unbounded following) as exit
  from activity_log)
  
  select
  landing,
  exit,
  count(distinct session) as count
  from 
  activity_log_with_landing_exit
  group by landing,exit
  ```
## 출구율(Exit Rate)&이탈율(Bounce Rate) 계산하기
### 출구율(Exit Rate)
* 경로별 출구율을 집계하는 쿼리
  ```sql
   with
  activity_log_with_exit_flag as(
  select
  	*,
  	case
  	when row_number() over (partition by session order by stamp desc)=1
  	then 1 else 0
  	end as is_exit
  from 
  activity_log)
  
  select
  path,
  sum(is_exit) as exit_count,
  count(*) as page_view,
  avg(100.0*is_exit) as exit_ratio
  from
  activity_log_with_exit_flag
  group by path
  ```
### 이탈율(Bounce Rate)
* 경로들의 이탈율을 집계하는 쿼리
  ```sql
    with
  activity_log_with_landing_bounce_flag as(
  select
  	*,
  	case
  	when row_number() over(partition by session order by stamp asc)=1
  	then 1 else 0
  	end as is_landing,
  	case
  	when count(*) over (partition by session)=1 then 1
  	else 0 end as is_bounce	
  from activity_log)
  
  select
  path,
  sum(is_bounce) as bounce_count,
  sum(is_landing) as landing_count,
  avg(100.0*case when is_landing=1 then is_bounce end) as bounce_ratio
  from activity_log_with_landing_bounce_flag
  group by path
  ```
## 3. 성과로 이어지는 페이지 확인하기
* Conversion Page보다 이전 접근에 플래그를 추가하는 쿼리
  ```sql
     with
   activity_log_with_conversion_flag as (
   select
   	session,
   	stamp,
   	path,
   	sign(sum(case when path='/complete' then 1 else 0 end)
   	over (partition by session order by stamp desc
   		 rows between unbounded preceding and current row))
   	as has_conversion
   from activity_log)
   
   select * from activity_log_with_conversion_flag
   order by session,stamp
  ```
  * `over (partition by session order by stamp desc rows between unbounded preceding and current row)`
    * 같은 `session`안에서 **시간 내림차순**으로 누적합을 계산
    * 각 시점 이후에 발생한 `/complete` 횟수의 누적값을 구하게 된다.
* 경로들의 방문 수&구성 수를 집계하기
  ```sql
    with
  activity_log_with_conversion_flag as (
  select
  	session,
  	stamp,
  	path,
  	sign(sum(case when path='/complete' then 1 else 0 end)
  	over (partition by session order by stamp desc
  		 rows between unbounded preceding and current row))
  	as has_conversion
  from activity_log)
  
  select
  path,
  count(distinct session) as sessions,
  sum(has_conversion) as conversions,
  1.0*sum(has_conversion)/count(distinct session) as cvr
  from activity_log_with_conversion_flag
  group by path
  ```
## 4. 페이지 가치 산출하기
* 페이지 가치 할당을 계산하기
  ```sql
    with
  activity_log_with_session_conversion_flag as (
  select
  	session,
  	stamp,
  	path,
  	sign(sum(case when path='/complete' then 1 else 0 end)
  	over (partition by session order by stamp desc
  		 rows between unbounded preceding and current row)) as has_conversion
  from activity_log),
  
  activity_log_with_conversion_assing as (
  select
  	session,stamp,path,
  	row_number() over (partition by session order by stamp asc) as asc_order,
  	row_number() over (partition by session order by stamp desc) as desc_order,
  	count(*) over(partition by session) as page_count,
  	1000.0/count(*) over (partition by session) as fair_assign,
  	case
  	when row_number() over(partition by session order by stamp asc)=1
  	then 1000.0 else 0.0 end as first_assign,
  	case
  	when row_number() over(partition by session order by stamp desc)=1
  	then 1000.0 else 0.0 end as last_assign,
  	1000.0*row_number() over(partition by session order by stamp asc)/
  	(count(*) over (partition by session)*(count(*) over(partition by session)+1)/2)
  	as decrease_assign,
  	1000.0*row_number() over(partition by session order by stamp desc)/
  	(count(*)over(partition by session)*(count(*) over(partition by session)+1)/2)
  	as increase_assign
  from activity_log_with_session_conversion_flag
  where has_conversion=1
  and path not in ('/input','/confirm','/complete'))
  
  select
  session,asc_order,path,
  fair_assign as fair_a,
  first_assign as first_a,
  last_assign as last_a,
  decrease_assign as dec_a,
  increase_assign as inc_a
  from activity_log_with_conversion_assing
  order by session,asc_order
  ```
* 경로별 페이지 가치 합계를 구하는 쿼리
  ```sql
    with
  activity_log_with_session_conversion_flag as (
  select
  	session,
  	stamp,
  	path,
  	sign(sum(case when path='/complete' then 1 else 0 end)
  	over (partition by session order by stamp desc
  		 rows between unbounded preceding and current row)) as has_conversion
  from activity_log),
  
  activity_log_with_conversion_assing as (
  select
  	session,stamp,path,
  	row_number() over (partition by session order by stamp asc) as asc_order,
  	row_number() over (partition by session order by stamp desc) as desc_order,
  	count(*) over(partition by session) as page_count,
  	1000.0/count(*) over (partition by session) as fair_assign,
  	case
  	when row_number() over(partition by session order by stamp asc)=1
  	then 1000.0 else 0.0 end as first_assign,
  	case
  	when row_number() over(partition by session order by stamp desc)=1
  	then 1000.0 else 0.0 end as last_assign,
  	1000.0*row_number() over(partition by session order by stamp asc)/
  	(count(*) over (partition by session)*(count(*) over(partition by session)+1)/2)
  	as decrease_assign,
  	1000.0*row_number() over(partition by session order by stamp desc)/
  	(count(*)over(partition by session)*(count(*) over(partition by session)+1)/2)
  	as increase_assign
  from activity_log_with_session_conversion_flag
  where has_conversion=1
  and path not in ('/input','/confirm','/complete')),
  
  page_total_values as (
  select
  	path,
  	sum(fair_assign) as fair_assign,
  	sum(first_assign) as first_assign,
  	sum(last_assign) as last_assign
  from activity_log_with_conversion_assing
  group by path)
  
  select * from page_total_values
  ```
* 경로들의  평균 페이지 가치를 구하기
  ```sql
    with
  activity_log_with_session_conversion_flag as (
  select
  	session,
  	stamp,
  	path,
  	sign(sum(case when path='/complete' then 1 else 0 end)
  	over (partition by session order by stamp desc
  		 rows between unbounded preceding and current row)) as has_conversion
  from activity_log),
  
  activity_log_with_conversion_assing as (
  select
  	session,stamp,path,
  	row_number() over (partition by session order by stamp asc) as asc_order,
  	row_number() over (partition by session order by stamp desc) as desc_order,
  	count(*) over(partition by session) as page_count,
  	1000.0/count(*) over (partition by session) as fair_assign,
  	case
  	when row_number() over(partition by session order by stamp asc)=1
  	then 1000.0 else 0.0 end as first_assign,
  	case
  	when row_number() over(partition by session order by stamp desc)=1
  	then 1000.0 else 0.0 end as last_assign,
  	1000.0*row_number() over(partition by session order by stamp asc)/
  	(count(*) over (partition by session)*(count(*) over(partition by session)+1)/2)
  	as decrease_assign,
  	1000.0*row_number() over(partition by session order by stamp desc)/
  	(count(*)over(partition by session)*(count(*) over(partition by session)+1)/2)
  	as increase_assign
  from activity_log_with_session_conversion_flag
  where has_conversion=1
  and path not in ('/input','/confirm','/complete')),
  
  page_total_values as (
  select
  	path,
  	sum(fair_assign) as fair_assign,
  	sum(first_assign) as first_assign,
  	sum(last_assign) as last_assign
  from activity_log_with_conversion_assing
  group by path),
  
  page_total_cnt as (
  select
  	path,
  	count(*) as access_cnt,
  	count(distinct session) as access_cnt
  from activity_log
  group by path)
  
  select
  s.path,
  s.access_cnt,
  v.sum_fair/s.access_cnt as avg_fair,
  v.sum_first/s.access_cnt as avg_first,
  v.sum_last/s.access_cnt as avg_last,
  v.sum_dec/s.access_cnt as avg_dec,
  v.sum_inc/s.access_cnt as avg_inc
  from page_total_cnt as s
  join page_total_values as v
  on s.path=v.path
  order by s.access_cnt desc
  ```
## 5.검색 조건들의 사용자 행동 가시화 하기
* 클릭 플래그와 컨버전 플래그를 계산하는 쿼리
  ```sql
    with
  activity_log_with_session_click_conversion_flag as (
  select
  	session,
  	stamp,
  	path,
  	search_type,
  	sign(sum(case when path='/detail' then 1 else 0 end)
  	over(partition by session order by stamp desc
  		rows between unbounded preceding and current row)) as has_session_click,
  	sign(sum(case when path='/complete' then 1 else 0 end)
  	over(partition by session order by stamp desc
  		rows between unbounded preceding and current row)) as has_session_conversion	
  from activity_log)
  
  select
  session,
  stamp,
  path,
  search_type,
  has_session_click as click,
  has_session_conversion as cnv
  from activity_log_with_session_click_conversion_flag 
  order by session,stamp
  ```
* 검색 타입별 CTR,CVR 집계
  ```sql
     with
   activity_log_with_session_click_conversion_flag as (
   select
   	session,
   	stamp,
   	path,
   	search_type,
   	sign(sum(case when path='/detail' then 1 else 0 end)
   	over(partition by session order by stamp desc
   		rows between unbounded preceding and current row)) as has_session_click,
   	sign(sum(case when path='/complete' then 1 else 0 end)
   	over(partition by session order by stamp desc
   		rows between unbounded preceding and current row)) as has_session_conversion	
   from activity_log)
   
   select
   search_type,
   count(*) as count,
   sum(has_session_click) as detail,
   avg(has_session_click) as ctr,
   sum(case when has_session_click=1 then has_session_conversion end) as conversion,
   sum(case when has_session_click=1 then has_session_conversion end) as cvr
   from 
   activity_log_with_session_click_conversion_flag
   where
   path='/search_list'
   group by search_type
   order by count desc
  ```
* 클릭 플래그를 직전 페이지에 한정하는 쿼리
  ```sql
     with
   activity_log_with_session_click_conversion_flag as (
   select
   	session,
   	stamp,
   	path,
   	search_type,
   	case
   	when lag(path) over (partition by session order by stamp desc)='/detail'
   	then 1 else 0
   	end as has_session_click,
   	sign(sum(case when path='/complete' then 1 else 0 end)
   	over (partition by session order by stamp desc
   		 rows between unbounded preceding and current row)) as has_session_conversion
   from activity_log)
   
   select
   session,
   stamp,
   path,
   search_type,
   has_session_click as click,
   has_session_conversion as cnv
   from activity_log_with_session_click_conversion_flag
   order by session,stamp
  ```
## 6.Fallout 리포트를 사용해 사용자 회유를 가시화 하기
* Fallout 단계 순서를 접근하는 쿼리
  ```sql
    with
  mst_fallout_step as (
  select 1 as step, '/' as path
  union all select 2 as step, '/search_list/' as path
  union all select 3 as step, '/detail/' as path
  union all select 4 as step, '/input/' as path
  union all select 5 as ste, '/complete/' as path),
  
  activity_log_with_fallout_step as (
  select
  	l.session,m.step,m.path,
  	max(l.stamp) as max_stamp,
  	min(l.stamp) as min_stamp
  from mst_fallout_step as m
  join activity_log as l
  on m.path=l.path
  group by l.session,m.step,m.path),
  
  activity_log_with_mod_fallout_step as (
  select
  	session,step,path,max_step,
  	lag(min_stamp) over (partition by session order by step) as lag_min_stamp,
  	min(step) over (partition by session) as min_step,
  	count(*) over (partition by session order by step
  				  rows between unbounded preceding and current row) as cum_count
  from activity_log_fallout_step)
  ```
* Fallout 리포트에 필요한 로그를 압축
  ```sql
      with
    mst_fallout_step as (
    select 1 as step, '/' as path
    union all select 2 as step, '/search_list/' as path
    union all select 3 as step, '/detail/' as path
    union all select 4 as step, '/input/' as path
    union all select 5 as ste, '/complete/' as path),
    
    activity_log_with_fallout_step as (
    select
    	l.session,m.step,m.path,
    	max(l.stamp) as max_stamp,
    	min(l.stamp) as min_stamp
    from mst_fallout_step as m
    join activity_log as l
    on m.path=l.path
    group by l.session,m.step,m.path),
    
    activity_log_with_mod_fallout_step as (
    select
    	session,step,path,max_step,
    	lag(min_stamp) over (partition by session order by step) as lag_min_stamp,
    	min(step) over (partition by session) as min_step,
    	count(*) over (partition by session order by step
    				  rows between unbounded preceding and current row) as cum_count
    from activity_log_fallout_step),
    
    fallout_log as (
    select
    	session,step,path
    from activity_log_with_mod_fallout_step
    where min_step=1
    and step=cum_count
    and (lag_min_stamp is null
    	or max_stamp>=lag_min_stamp))
  ```
* Fallout 리포트를 출력
  ```sql
     with
   mst_fallout_step as (
   select 1 as step, '/' as path
   union all select 2 as step, '/search_list/' as path
   union all select 3 as step, '/detail/' as path
   union all select 4 as step, '/input/' as path
   union all select 5 as ste, '/complete/' as path),
   
   activity_log_with_fallout_step as (
   select
   	l.session,m.step,m.path,
   	max(l.stamp) as max_stamp,
   	min(l.stamp) as min_stamp
   from mst_fallout_step as m
   join activity_log as l
   on m.path=l.path
   group by l.session,m.step,m.path),
   
   activity_log_with_mod_fallout_step as (
   select
   	session,step,path,max_stamp,
   	lag(min_stamp) over (partition by session order by step) as lag_min_stamp,
   	min(step) over (partition by session) as min_step,
   	count(*) over (partition by session order by step
   				  rows between unbounded preceding and current row) as cum_count
   from activity_log_with_fallout_step),
   
   fallout_log as (
   select
   	session,step,path
   from activity_log_with_mod_fallout_step
   where min_step=1
   and step=cum_count
   and (lag_min_stamp is null
   	or max_stamp>=lag_min_stamp))
   
   select
   step,path,count(*),
   100.0*count(*)
   /first_value(count(*)) over(order by step asc rows between unbounded preceding and unbounded following)
   as first_trans_rate,
   100.0*count(*)
   /lag(count(*)) over (order by step asc) as step_trans_rate
   from fallout_log
   group by step,path
   order by step
  ```
## 7. 사이트 내부에서 사용자 흐름 파악하기
### 다음 페이지 집계하기
* /detail/ 페이지 이후 사용자 흐름을 집계
  ```sql
    with
  activity_log_with_lead_path as (
  select
  	session,stamp,
  	path as path0,
  	lead(path,1) over (partition by session order by stamp asc) as path1,
  	lead(path,2) over (partition by session order by stamp asc) as path2
  from activity_log),
  
  raw_user_flow as (
  select
  	path0,
  	sum(count(*)) over() as count0,
  	coalesce(path1,'null') as path1,
  	sum(count(*)) over(partition by path0,path1) as count1,
  	coalesce(path2,'null') as path2,
  	count(*) as count2
  from activity_log_with_lead_path
  where path0='/detail/'
  group by path0,path1,path2)
  
  select
  path0,count0,path1,count1,
  100.0*count1/count0 as rate1,
  path2,count2,
  100.0*count2/count1 as rate
  from raw_user_flow
  order by count1 desc, count2 desc
  ```
* 바로 위의 레코드와 같은 값을 가졌을때 출력하지 않게 가공하기
  ```sql
     with
   activity_log_with_lead_path as (
   select
   	session,stamp,
   	path as path0,
   	lead(path,1) over (partition by session order by stamp asc) as path1,
   	lead(path,2) over (partition by session order by stamp asc) as path2
   from activity_log),
   
   raw_user_flow as (
   select
   	path0,
   	sum(count(*)) over() as count0,
   	coalesce(path1,'null') as path1,
   	sum(count(*)) over(partition by path0,path1) as count1,
   	coalesce(path2,'null') as path2,
   	count(*) as count2
   from activity_log_with_lead_path
   where path0='/detail/'
   group by path0,path1,path2)
   
   select
   case 
   when
   coalesce(lag(path0) over (order by count1 desc,count2 desc),'NOT FOUND')<>path0
   then path0 end as path0,
   case
   when
   coalesce(lag(path0) over(order by count1 desc, count2 desc),'NOT FOUND')<>path0
   then count0 end as count0,
   case
   when coalesce(lag(path0||path1) over(order by count1 desc, count2 desc),'NOT FOUND')<>(path0||path1)
   then path1 end as page1,
   case
   when coalesce(lag(path0||path1) over(order by count1 desc, count2 desc),'NOT FOUND')<>(path0||path1)
   then count1 end as count1,
   case
   when coalesce(lag(path0||path1) over(order by count1 desc, count2 desc),'NOT FOUND')<>(path0||path1)
   then 100.0*count1/count0 end as rate1,
   case
   when coalesce(lag(path0||path1||path2) over(order by count1 desc, count2 desc),'NOT FOUND')<>(path0||path1||path2)
   then path2 end as page2,
   case
   when coalesce(lag(path0||path1||path2) over(order by count1 desc, count2 desc),'NOT FOUND')<>(path0||path1||path2)
   then count2 end as count2,
   case
   when coalesce(lag(path0||path1||path2) over(order by count1 desc, count2 desc),'NOT FOUND')<>(path0||path1||path2)
   then 100.0*count2/count1 end as rate2
   from raw_user_flow
   order by count1 desc,count2 desc
  ```
### 이전 페이지 집계하기
* /detail/ 페이지 이전의 사용자 흐름을 집계
  ```sql
     with
   activity_log_with_lag_path as (
   select
   	session,stamp,path as path0,
   	coalesce(lag(path,1) over(partition by session order by stamp asc),'NULL') as path1,
   	coalesce(lag(path,2) over(partition by session order by stamp asc),'NULL') as path2
   from activity_log),
   
   raw_user_flow as (
   select
   	path0,
   	sum(count(*)) over() as count0,
   	path1,
   	sum(count(*)) over(partition by path0,path1) as count1,
   	path2,
   	count(*) as count2
   from activity_log_with_lag_path
   where path0='/detail/'
   group by path0,path1,path2)
   
   select
   path2,count2,
   100.0*count2/count1 as rate2,
   path1,count1,
   100.0*count1/count0 as rate1,
   path0,count0
   from
   raw_user_flow
   order by count1 desc, count2 desc
  ```
           
                 
                      
                  
             
              
            
            
          
              
                
              
              
               
               
               
